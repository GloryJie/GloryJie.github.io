[{"content":" 封面壁纸为国漫《仙逆》的女主 李慕婉\n射线法简介 射线法的基本思想是重目标点向一个方向引出一条无限的射线法，统计射线与多边形的边相交的数量\n如果是偶数，则点在多边形外 如果是奇数，则点在多边形内 一般射线的方向是x轴的正数方向。算法的时间复杂度为O(n)，n为多边形的边（点）数。\n情况列举和分享 下面几种情况都算是点在多边形内\n点在多边形内 点和多边形的顶点重叠 点在多边形的边上 射线法将判断在多边形内，转移为判断点和边的关系。所以算法的主要逻辑，就是在判断点射线和边的空间关系。有两种情况需要特殊处理。\n射线经过边的顶点 判断点在斜线的左侧的三角函数 从点引出的射线和多边形的边有下面几种情况需要考虑\n点在在边的上方、下方、右侧，不会相交 边水平的情况，不判断交点数，只判断是否在线上 射线经过边的顶点，则需要使用权重值来解决经过顶点的问题（涵盖了边垂直的情况） B点在A点的下方，那么权重值-0.5 B点在A点的上方，那么权重值+0.5 边垂直的情况 点在垂直的边P上，则点在多边形内 点在在垂直的边的左边，则点与该边必然有交点 边斜线的情况 点在线的左边，肯定会有交点 通过三角函数来判断点是否在边的左边 各种情况的判断代码 点的表达\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 @Data @AllArgsConstructor @NoArgsConstructor public class Point { /** * 经度 */ private Double lng; /** * 纬度 */ private Double lat; } 目标点和多边形的顶点重合\n1 2 3 4 5 6 // 顶点重合的情况 for (Point polygonPoint : polygonPoints) { if (Objects.equals(target, polygonPoint)) { return true; } } 点在的上方、下方、右侧，射线肯定不会和边相交\n1 2 3 4 if (target.getLat() \u0026lt; minLat || target.getLat() \u0026gt; maxLat || target.getLng() \u0026gt; maxLng) { pointA = pointB; continue; } 边水平的情况,若点在水平的边上，则点在多边形内。平行重叠的情况，不做交点数判断。\n1 2 3 4 5 6 7 if (Objects.equals(pointA.getLat(), pointB.getLat())) { if (target.getLng() \u0026lt;= maxLng \u0026amp;\u0026amp; target.getLng() \u0026gt;= minLng) { return true; } pointA = pointB; continue; } 射线经过边的顶点(此时边可能垂直)，解决方案为：如果交点是待测多边形某个边上的一个顶点，则只有当该边的另一个顶点位于射线下方时，交点才算在内。这实际上等同于将与射线相交的顶点视为略高于射线。\n1 2 3 4 5 6 7 8 9 10 11 12 if ((Objects.equals(target.getLat(), pointA.getLat()) \u0026amp;\u0026amp; target.getLng() \u0026lt; pointA.getLng()) || Objects.equals(target.getLat(), pointB.getLat()) \u0026amp;\u0026amp; target.getLng() \u0026lt; pointB.getLng()) { if (pointB.getLat() \u0026lt; pointA.getLat()) { // B点在A点的下方，那么权重值-0.5 intersectPointWeights -= 0.5; } else if (pointB.getLat() \u0026gt; pointA.getLat()) { // B点在A点的上方，那么权重值+0.5 intersectPointWeights += 0.5; } pointA = pointB; continue; } 边垂直的情况\n1 2 3 4 5 6 7 8 9 10 11 12 if (Objects.equals(pointA.getLng(), pointB.getLng())) { if (Objects.equals(target.getLng(), pointA.getLng())) { // 若点在垂直的边P上，则点在多边形内 return true; } else if (target.getLng() \u0026lt; pointA.getLng()) { // 若点在在垂直的边的左边，则点与该边必然有交点 intersectPointCount++; } pointA = pointB; continue; } 边斜线的情况，使用三角函数来判断\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 if (target.getLng() \u0026lt;= minLng) { // 点point的x坐标在边的左侧，那么肯定相交 intersectPointCount++; } else if (target.getLng() \u0026lt; maxLng) { // 点point的x坐标在点B、A的x坐标中间 double diff = (target.getLat() - pointA.getLat()) * (pointA.getLng() - pointB.getLng()) / (pointA.getLat() - pointB.getLat()) + pointA.getLng() - target.getLng(); if (diff \u0026gt;= 0) { if (diff \u0026lt; PRECISION) { // 由于double精度在计算时会有损失，故匹配一定的容差 // 点在斜线P1P2上 return true; } else { // 点向右射线与斜线P1P2有交点 intersectPointCount++; } } } 测试示例 图形如下\n点集合，也就是多边形\n1 [{\u0026#34;lng\u0026#34;:110.269889,\u0026#34;lat\u0026#34;:21.308982},{\u0026#34;lng\u0026#34;:110.277883,\u0026#34;lat\u0026#34;:21.231378},{\u0026#34;lng\u0026#34;:110.275219,\u0026#34;lat\u0026#34;:21.178585},{\u0026#34;lng\u0026#34;:110.309195,\u0026#34;lat\u0026#34;:21.166692},{\u0026#34;lng\u0026#34;:110.345361,\u0026#34;lat\u0026#34;:21.166692},{\u0026#34;lng\u0026#34;:110.345361,\u0026#34;lat\u0026#34;:21.225846},{\u0026#34;lng\u0026#34;:110.37871,\u0026#34;lat\u0026#34;:21.218632},{\u0026#34;lng\u0026#34;:110.416809,\u0026#34;lat\u0026#34;:21.210863},{\u0026#34;lng\u0026#34;:110.41919,\u0026#34;lat\u0026#34;:21.224181},{\u0026#34;lng\u0026#34;:110.419648,\u0026#34;lat\u0026#34;:21.234822},{\u0026#34;lng\u0026#34;:110.385148,\u0026#34;lat\u0026#34;:21.282747},{\u0026#34;lng\u0026#34;:110.351299,\u0026#34;lat\u0026#34;:21.286387},{\u0026#34;lng\u0026#34;:110.269889,\u0026#34;lat\u0026#34;:21.308982}] 测试代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 System.out.println(\u0026#34;图形外，射线和线水平，不在线上：\u0026#34; + RayCastUtil.isPointInPolygon(new Point(110.301195,21.166692), polygonPointList)); System.out.println(\u0026#34;图形内, 射线和线水平，在线上：\u0026#34; + RayCastUtil.isPointInPolygon(new Point(110.319195,21.166692), polygonPointList)); System.out.println(\u0026#34;图形内，射线和线垂直：\u0026#34; + RayCastUtil.isPointInPolygon(new Point(110.319195,21.186692), polygonPointList)); System.out.println(\u0026#34;图形外，射线和线垂直：\u0026#34; + RayCastUtil.isPointInPolygon(new Point(110.219195,21.186692), polygonPointList)); System.out.println(\u0026#34;图形内，经过线顶点：\u0026#34; + RayCastUtil.isPointInPolygon(new Point(110.305361,21.225846), polygonPointList)); System.out.println(\u0026#34;图形外，经过线顶点：\u0026#34; + RayCastUtil.isPointInPolygon(new Point(110.245361,21.225846), polygonPointList)); System.out.println(\u0026#34;图形内，和一条斜线相交：\u0026#34; + RayCastUtil.isPointInPolygon(new Point(110.305361,21.265846), polygonPointList)); System.out.println(\u0026#34;图形外，和一条斜线相交：\u0026#34; + RayCastUtil.isPointInPolygon(new Point(110.245361,21.265846), polygonPointList)); System.out.println(\u0026#34;图形内，和多条线相交：\u0026#34; + RayCastUtil.isPointInPolygon(new Point(110.305361,21.221846), polygonPointList)); System.out.println(\u0026#34;图形外，和多条线相交：\u0026#34; + RayCastUtil.isPointInPolygon(new Point(110.245361,21.221846), polygonPointList)); 完整代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 public class RayCastUtil { private static final double PRECISION = 2e-10; public static boolean isPointInPolygon(Point target, List\u0026lt;Point\u0026gt; polygonPoints) { // 这里不需要首尾相连，有些不需要，这就 if (Objects.equals(polygonPoints.get(0), polygonPoints.get(polygonPoints.size() - 1))) { polygonPoints = polygonPoints.subList(0, polygonPoints.size() - 1); } // 顶点重合的情况 for (Point polygonPoint : polygonPoints) { if (Objects.equals(target, polygonPoint)) { return true; } } // X轴射线与多边形的交点数 int intersectPointCount = 0; // X轴射线与多边形顶点相交的权值 double intersectPointWeights = 0; // pointA -\u0026gt; pointB 代表一条边 Point pointA = polygonPoints.get(0); Point pointB = null; final int pointSize = polygonPoints.size(); for (int i = 1; i \u0026lt;= pointSize; i++) { // for中定义\u0026lt;=以及这里的%取余，是为了关注最后一个节点连接首节点这条边的情况 pointB = polygonPoints.get(i % pointSize); double minLat = Math.min(pointA.getLat(), pointB.getLat()); double maxLat = Math.max(pointA.getLat(), pointB.getLat()); double minLng = Math.min(pointA.getLng(), pointB.getLng()); double maxLng = Math.max(pointA.getLng(), pointB.getLng()); // 目标点在的上方、下方、右侧，那么就不会相交 if (target.getLat() \u0026lt; minLat || target.getLat() \u0026gt; maxLat || target.getLng() \u0026gt; maxLng) { pointA = pointB; continue; } // 边水平的情况,若点在水平的边上，则点在多边形内, if (Objects.equals(pointA.getLat(), pointB.getLat())) { if (target.getLng() \u0026lt;= maxLng \u0026amp;\u0026amp; target.getLng() \u0026gt;= minLng) { return true; } pointA = pointB; continue; } // 边界处理：射线经过边的顶点(此时边可能垂直) if ((Objects.equals(target.getLat(), pointA.getLat()) \u0026amp;\u0026amp; target.getLng() \u0026lt; pointA.getLng()) || Objects.equals(target.getLat(), pointB.getLat()) \u0026amp;\u0026amp; target.getLng() \u0026lt; pointB.getLng()) { if (pointB.getLat() \u0026lt; pointA.getLat()) { // B点在A点的下方，那么权重值-0.5 intersectPointWeights -= 0.5; } else if (pointB.getLat() \u0026gt; pointA.getLat()) { // B点在A点的上方，那么权重值+0.5 intersectPointWeights += 0.5; } pointA = pointB; continue; } // 边垂直的情况 if (Objects.equals(pointA.getLng(), pointB.getLng())) { if (Objects.equals(target.getLng(), pointA.getLng())) { // 若点在垂直的边P上，则点在多边形内 return true; } else if (target.getLng() \u0026lt; pointA.getLng()) { // 若点在在垂直的边的左边，则点与该边必然有交点 intersectPointCount++; } pointA = pointB; continue; } // 边斜的情况 if (target.getLng() \u0026lt;= minLng) { // 点point的x坐标在边的左侧，那么肯定相交 intersectPointCount++; } else if (target.getLng() \u0026lt; maxLng) { // 点point的x坐标在点B、A的x坐标中间 double diff = (target.getLat() - pointA.getLat()) * (pointA.getLng() - pointB.getLng()) / (pointA.getLat() - pointB.getLat()) + pointA.getLng() - target.getLng(); if (diff \u0026gt;= 0) { if (diff \u0026lt; PRECISION) { // 由于double精度在计算时会有损失，故匹配一定的容差 // 点在斜线P1P2上 return true; } else { // 点向右射线与斜线P1P2有交点 intersectPointCount++; } } } pointA = pointB; } return (intersectPointCount + Math.abs(intersectPointWeights)) % 2 != 0; } } 附录 参考 YouTube视频：Checking if a point is inside a polygon is RIDICULOUSLY simple (Ray casting algorithm) - Inside code\n判断点是否在多边形内的Python实现及小应用（射线法）\n维基百科：多边形内的点\n","date":"2024-03-04T20:33:08+08:00","image":"https://gloryjie.github.io/p/%E5%B0%84%E7%BA%BF%E6%B3%95-%E5%88%A4%E6%96%AD%E7%82%B9%E6%98%AF%E5%90%A6%E5%9C%A8%E5%A4%9A%E8%BE%B9%E5%BD%A2%E5%86%85/cover_hue2c682d0e4643ecbc5c998a202920083_1132640_120x120_fill_q75_box_smart1.jpeg","permalink":"https://gloryjie.github.io/p/%E5%B0%84%E7%BA%BF%E6%B3%95-%E5%88%A4%E6%96%AD%E7%82%B9%E6%98%AF%E5%90%A6%E5%9C%A8%E5%A4%9A%E8%BE%B9%E5%BD%A2%E5%86%85/","title":"射线法 判断点是否在多边形内"},{"content":" 1 封面是《死亡搁浅》游戏中的 玛玛 官方有教程：https://resilience4j.readme.io/v1.7.0/docs/getting-started-3\n这里做个简单使用记录。 版本要求 Resilience4j版本 JDK版本 1.7 8 2.0 17 这里用的jdk8，使用Resilience4j的1.7版本。mvn依赖如下\n1 2 3 4 5 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;io.github.resilience4j\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;resilience4j-spring-boot2\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.7.1\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 这个包把Resilience4j的基本组件都引入进来了。\nyml配置 配置可以有三个层级的配置，分别可以继承。\n修改默认配置 自定义可共享的配置 实例自定义配置 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 resilience4j.circuitbreaker: # 指定对应的组件 configs: default: # 修改默认配置 slidingWindowSize: 100 permittedNumberOfCallsInHalfOpenState: 10 waitDurationInOpenState: 10000 failureRateThreshold: 60 eventConsumerBufferSize: 10 registerHealthIndicator: true someShared: # 可共享的配置 slidingWindowSize: 50 permittedNumberOfCallsInHalfOpenState: 10 instances: # 下面是实例自定义配置 backendA: # 实例名称 baseConfig: default # 指定继承的配置 waitDurationInOpenState: 5000 backendB: baseConfig: someShared 事件监听器 Resilience4j提供了两种细粒度的时间监听\nRegistry组件的增、删、替换事件 组件实例的状态变化事件 Resilience4j原生使用时在对应组件实例的基础上去进行设置监听，但是结合SpringBoot之后是没有办法直接拿到对应的组件实例。可以通过监听实例的增、删、替换的动作，进而拿到对应的实例，之后再进行监听实例状态的变更。\n自己创建的RegistryEventConsumer的Bean，会自动添加到SpringBoot自身管理的CircuitBreakerRegistry中。\n以监听CircuitBreaker组件为例，参考代码如下（IMessageService为自己的bean）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 @Bean public RegistryEventConsumer\u0026lt;CircuitBreaker\u0026gt; circuitBreakerEventConsumer(IMessageService messageService){ return new RegistryEventConsumer\u0026lt;CircuitBreaker\u0026gt;() { @Override public void onEntryAddedEvent(EntryAddedEvent\u0026lt;CircuitBreaker\u0026gt; entryAddedEvent) { entryAddedEvent.getAddedEntry().getEventPublisher().onStateTransition(event -\u0026gt; { String circuitBreakerName = event.getCircuitBreakerName(); CircuitBreaker.State fromState = event.getStateTransition().getFromState(); CircuitBreaker.State toState = event.getStateTransition().getToState(); log.info(\u0026#34;CircuitBreaker \u0026#39;{}\u0026#39; changed state from {} to {}\u0026#34;, circuitBreakerName, fromState, toState); StringBuilder builder = new StringBuilder(); builder.append(\u0026#34;\u0026lt;font color=\\\u0026#34;warning\\\u0026#34;\u0026gt;断路器状态发生变化 \u0026#34;).append(DateUtil.now()).append(\u0026#34; \u0026lt;/font\u0026gt;\\n\u0026#34;); builder.append(\u0026#34;\u0026gt; 断路器名称：\u0026#34;).append(circuitBreakerName).append(\u0026#34;\\n\u0026#34;); builder.append(\u0026#34;\u0026gt; 变化前状态：\u0026#34;).append(fromState).append(\u0026#34;\\n\u0026#34;); builder.append(\u0026#34;\u0026gt; 变化后状态：\u0026#34;).append(toState).append(\u0026#34;\\n\u0026#34;); builder.append(\u0026#34;请尽快处理！！！\u0026#34;); messageService.reportDefaultMsg(builder.toString()); }); } @Override public void onEntryRemovedEvent(EntryRemovedEvent\u0026lt;CircuitBreaker\u0026gt; entryRemoveEvent) { } @Override public void onEntryReplacedEvent(EntryReplacedEvent\u0026lt;CircuitBreaker\u0026gt; entryReplacedEvent) { } }; } 使用形式 注解使用 只需要在对应的方法加上对应组件的直接即可。还可以在添加降级处理的方，会自动根据异常类型进行批量。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 @CircuitBreaker(name = BACKEND, fallbackMethod = \u0026#34;fallback\u0026#34;) @RateLimiter(name = BACKEND) @Bulkhead(name = BACKEND, fallbackMethod = \u0026#34;fallback\u0026#34;) @Retry(name = BACKEND) @TimeLimiter(name = BACKEND) public Mono\u0026lt;String\u0026gt; method(String param1) { return Mono.error(new NumberFormatException()); } private Mono\u0026lt;String\u0026gt; fallback(String param1, CallNotPermittedException e) { return Mono.just(\u0026#34;Handled the exception when the CircuitBreaker is open\u0026#34;); } private Mono\u0026lt;String\u0026gt; fallback(String param1, BulkheadFullException e) { return Mono.just(\u0026#34;Handled the exception when the Bulkhead is full\u0026#34;); } private Mono\u0026lt;String\u0026gt; fallback(String param1, NumberFormatException e) { return Mono.just(\u0026#34;Handled the NumberFormatException\u0026#34;); } // 其实也可以写一个通用的，内部if else好了，减少方法的数量 private Mono\u0026lt;String\u0026gt; fallback(String param1, Exception e) { return Mono.just(\u0026#34;Handled any other exception\u0026#34;); } 代码使用 注解都是基于AOP去处理的，通病就是调用内部方法的时候是不会生效的。可以手动获取到对应的实力。\n1 2 3 4 5 @Resource private CircuitBreakerRegistry circuitBreakerRegistry; // 从registry获取实例，和注解使用的是同一个实例 circuitBreakerRegistry.circuitBreaker(\u0026#34;tencentAddressService\u0026#34;); starter的配置过程 结合SpringBoot的starter，流程基本就是读取配置，创建各种Bean组件。提供了各种注解，则过程就是基于Aop去实现的。这里简单看下CircuitBreaker的实现过程。\n基本涉及两个类\nCircuitBreakerConfiguration配置类，负责启动时创建断路器相关的Bean CircuitBreakerAspect切面处理，CircuitBreaker注解的处理 Bean的生成 两个关键的Bean\nCircuitBreakerRegistry CircuitBreakerAspect 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 @Bean @Primary public RegistryEventConsumer\u0026lt;CircuitBreaker\u0026gt; circuitBreakerRegistryEventConsumer( Optional\u0026lt;List\u0026lt;RegistryEventConsumer\u0026lt;CircuitBreaker\u0026gt;\u0026gt;\u0026gt; optionalRegistryEventConsumers) { // 自定义的RegistryEventConsumer会注入进来 return new CompositeRegistryEventConsumer\u0026lt;\u0026gt;( optionalRegistryEventConsumers.orElseGet(ArrayList::new)); } @Bean public CircuitBreakerRegistry circuitBreakerRegistry( EventConsumerRegistry\u0026lt;CircuitBreakerEvent\u0026gt; eventConsumerRegistry, RegistryEventConsumer\u0026lt;CircuitBreaker\u0026gt; circuitBreakerRegistryEventConsumer, @Qualifier(\u0026#34;compositeCircuitBreakerCustomizer\u0026#34;) CompositeCustomizer\u0026lt;CircuitBreakerConfigCustomizer\u0026gt; compositeCircuitBreakerCustomizer) { CircuitBreakerRegistry circuitBreakerRegistry = createCircuitBreakerRegistry( circuitBreakerProperties, circuitBreakerRegistryEventConsumer, compositeCircuitBreakerCustomizer); registerEventConsumer(circuitBreakerRegistry, eventConsumerRegistry); // then pass the map here initCircuitBreakerRegistry(circuitBreakerRegistry, compositeCircuitBreakerCustomizer); return circuitBreakerRegistry; } @Bean @Conditional(value = {AspectJOnClasspathCondition.class}) public CircuitBreakerAspect circuitBreakerAspect( CircuitBreakerRegistry circuitBreakerRegistry, @Autowired(required = false) List\u0026lt;CircuitBreakerAspectExt\u0026gt; circuitBreakerAspectExtList, FallbackDecorators fallbackDecorators, SpelResolver spelResolver ) { return new CircuitBreakerAspect(circuitBreakerProperties, circuitBreakerRegistry, circuitBreakerAspectExtList, fallbackDecorators, spelResolver); } 切面处理逻辑 切面的逻辑比较简单\n看看有没有注解 circuitBreakerRegistry中获取CircuitBreaker实例 是否使用fallback，不同的处理 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 @Pointcut(value = \u0026#34;@within(circuitBreaker) || @annotation(circuitBreaker)\u0026#34;, argNames = \u0026#34;circuitBreaker\u0026#34;) public void matchAnnotatedClassOrMethod(CircuitBreaker circuitBreaker) { } @Around(value = \u0026#34;matchAnnotatedClassOrMethod(circuitBreakerAnnotation)\u0026#34;, argNames = \u0026#34;proceedingJoinPoint, circuitBreakerAnnotation\u0026#34;) public Object circuitBreakerAroundAdvice(ProceedingJoinPoint proceedingJoinPoint, @Nullable CircuitBreaker circuitBreakerAnnotation) throws Throwable { // 方法上有没有注解 Method method = ((MethodSignature) proceedingJoinPoint.getSignature()).getMethod(); String methodName = method.getDeclaringClass().getName() + \u0026#34;#\u0026#34; + method.getName(); if (circuitBreakerAnnotation == null) { circuitBreakerAnnotation = getCircuitBreakerAnnotation(proceedingJoinPoint); } if (circuitBreakerAnnotation == null) { //because annotations wasn\u0026#39;t found return proceedingJoinPoint.proceed(); } // spel相关的 String backend = spelResolver.resolve(method, proceedingJoinPoint.getArgs(), circuitBreakerAnnotation.name()); io.github.resilience4j.circuitbreaker.CircuitBreaker circuitBreaker = getOrCreateCircuitBreaker( methodName, backend); Class\u0026lt;?\u0026gt; returnType = method.getReturnType(); String fallbackMethodValue = spelResolver.resolve(method, proceedingJoinPoint.getArgs(), circuitBreakerAnnotation.fallbackMethod()); // 没有fallback if (StringUtils.isEmpty(fallbackMethodValue)) { return proceed(proceedingJoinPoint, methodName, circuitBreaker, returnType); } // 有fallback FallbackMethod fallbackMethod = FallbackMethod .create(fallbackMethodValue, method, proceedingJoinPoint.getArgs(), proceedingJoinPoint.getTarget()); return fallbackDecorators.decorate(fallbackMethod, () -\u0026gt; proceed(proceedingJoinPoint, methodName, circuitBreaker, returnType)).apply(); } 附录 参考 官方教程 How to configure to events in Resilience4j Spring starter ","date":"2024-02-02T11:18:46+08:00","image":"https://gloryjie.github.io/p/resilience4j-%E6%95%B4%E5%90%88springboot/cover_hu3163765b57fc9a9b6b4dbc88ef7da476_2717844_120x120_fill_q75_box_smart1.jpg","permalink":"https://gloryjie.github.io/p/resilience4j-%E6%95%B4%E5%90%88springboot/","title":"Resilience4j-整合Springboot"},{"content":" 交友：扩充圈子，多认识妹子，多花时间进行线上交流；舍得花钱打扮 阅读：非技术书籍20+本，技术书籍10+，网文1本 运动：践行干净增肌，8个月增肌、3个月减脂，目标65kg 游戏：打完5+游戏，死亡搁浅、只狼、艾尔登法环、ffe7等 技术提升：基础增强（网络、操作系统）、算法LC刷题100道、接触AIGC 技术课程：至少一门国外课程（看完并做完实验），例如MIT6.824、MIT6.S081 项目实践：设计一个个人项目并上线运行 投资理财：继续学习相关知识，在尽可能不增加资金的情况下，回本！ 生活体验：出行游玩，如武功山、武汉、九寨沟 新技能：手机摄影\u0026amp;剪辑 习惯养成目标\n12点前入睡，7点起 行路中，不玩手机 每周进行总结 每月1~2本书 降低拖延症 ","date":"2024-01-04T17:47:55+08:00","image":"https://gloryjie.github.io/p/2024%E5%B9%B4%E5%BA%A6%E8%AE%A1%E5%88%92/cover_hu6b62954a64c9532f0495ca1fd21ae92d_130115_120x120_fill_box_smart1_3.png","permalink":"https://gloryjie.github.io/p/2024%E5%B9%B4%E5%BA%A6%E8%AE%A1%E5%88%92/","title":"2024年度计划"}]