[{"content":" 封面是韩国的Arin，下面是抖音经常刷到的一个装扮\n这里直接使用SDKMAN进行jdk21的下载。（安利SDKMan这个工具，本地用来切换各版本sdk方便）\n1 sdk install java 22.0.1-oracle 正式发布的（非预览）新特性。并对语法层面的，也就是核心Java库相关的做个简单记录。\nJEP 分类 虚拟线程 核心 Java 库 有序集合 核心 Java 库 Record 模式 核心 Java 库 switch 模式匹配 核心 Java 库 分代 ZGC HotSpot 弃用 Windows 32 位 x86 端口 HotSpot 准备禁止动态加载代理 HotSpot 密钥封装机制 API 安全库 有序集合 JEP 431\n对于有序集合，，如List（ArrayList、LinkList等）、Deqeue、SortedSet等，没有一个共同的操作语义api区队双端就行操作。下面距离取第一个、最优一个元素的当前方式。\nCollection First element Last element List list.get(0) list.get(list.size() - 1) Deque deque.getFirst() deque.getLast() SortedSet sortedSet.first() sortedSet.last() LinkedHashSet linkedHashSet.iterator().next() // missing 实际开发中最常见的就是list.get(0)、list.get(list.size() - 1)。在上述背景下，新增了三个接口：SequencedCollection、SequencedSet、SequencedMap。下面来看下这三个接口的相关定义。\n下面是三个接口在集合框架体系中的关系。 SequencedCollection接口定义如下，都是对于首尾操作的方法，还有一个反转顺序的操作。 SequencedSet继承自SequenceCollection，重写了reversed方法的返回值而已。 SequencedMap是自己单独定义的，需要留意两个方法的返回值\nsequencedKeySet返回SequencedSet sequenedValues返回SequencdCollection 对于首尾操作就不需要自己去遍历或者指定index了，还加多了一个reverse操作。\nRecord模式 JEP440\n对于Record在日常使用者，个人还没有使用上（日常工作还在Java8），感触不是很深，先不研究。\nswitch支持数据类型匹配 直观感受就是支持了数据类型匹配，还支持null匹配👍。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 public class Main { public static void main(String[] args) { System.out.println(getTypeStr(1)); System.out.println(getTypeStr(\u0026#34;hello\u0026#34;)); System.out.println(getTypeStr(12.12d)); System.out.println(getTypeStr(123L)); System.out.println(getTypeStr(true)); } public static String getTypeStr(Object o) { return switch (o) { case null -\u0026gt; \u0026#34;null\u0026#34;; case Integer i -\u0026gt; String.format(\u0026#34;int %d\u0026#34;, i); case Long l -\u0026gt; String.format(\u0026#34;long %d\u0026#34;, l); case Double d -\u0026gt; String.format(\u0026#34;double %f\u0026#34;, d); case String s -\u0026gt; String.format(\u0026#34;String %s\u0026#34;, s); case Boolean b -\u0026gt; String.format(\u0026#34;Boolean %b\u0026#34;, b); default -\u0026gt; o.toString(); }; } } VirtualThread虚拟线程 JEP444\n什么事虚拟线程？看下VirtualThread类上的注释。（一句话就明白了）\nA thread that is scheduled by the Java virtual machine rather than the operating system.\n对于开发者来说虚拟线程在使用体验上和 Thread 几乎没有区别，与之前的 API 互相兼容，但是相比之下虚拟线程资源占用非常少。下面来对比一下使用。\nThread类的使用方式\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // 原始线程的使用 Thread thread = new Thread(() -\u0026gt; { System.out.println(\u0026#34;hello thread\u0026#34;); }, \u0026#34;SystemThread\u0026#34;); thread.start(); // 虚拟线程 Thread virtualThread = Thread.ofVirtual().name(\u0026#34;VirtualThread\u0026#34;).unstarted(() -\u0026gt; { System.out.println(\u0026#34;hello virtual thread\u0026#34;); }); virtualThread.start(); Thread.startVirtualThread(() -\u0026gt; { System.out.println(\u0026#34;hello virtual thread, startVirtualThread\u0026#34;); }); ExecutorService线程池使用方式\n1 2 3 4 5 6 7 8 9 10 11 // 创建并提交执行虚拟线程 long start = System.currentTimeMillis(); try (var executor = Executors.newVirtualThreadPerTaskExecutor()) { IntStream.range(0, 10_000).forEach(i -\u0026gt; { executor.submit(() -\u0026gt; { Thread.sleep(Duration.ofSeconds(1)); return i; }); }); } System.out.println(\u0026#34;time:\u0026#34; + (System.currentTimeMillis() - start) + \u0026#34;ms\u0026#34;); VirtualThread是不需要池化的，用的时候新建即可。后续会对这一块进一步研究学习。 附录 参考 Java 21 新功能介绍 (LTS) 咖啡屋视频：通向Java21-02-Java虚拟线程 咖啡屋视频：通向Java21-04-新的API 咖啡屋视频：通向Java21-07-完整的模式匹配【最终回】 ","date":"2024-04-21T11:33:39+08:00","image":"https://gloryjie.github.io/p/java21%E8%AF%AD%E6%B3%95%E7%89%B9%E6%80%A7/cover_hua0dda0fd1975efc7e10ecc9bbca3e0a7_198222_120x120_fill_q75_box_smart1.jpeg","permalink":"https://gloryjie.github.io/p/java21%E8%AF%AD%E6%B3%95%E7%89%B9%E6%80%A7/","title":"Java21语法特性"},{"content":" 封面是《斗罗大陆2绝世唐门》中的凌落宸，用冰技能, 图片由AI生成，完成图片放在附录中\n课程首页以及实验说明相关介绍链接在附录中。\n课程理解 简单的说，就是用Go来实现一个单机多进程版本的MapReduce。(MapReduce计算模型可以去搜索相关文章了解)。会有如下两种类型的进程\nCoordinator协调者：作为一个协调着，协调Map、Reduce的任务交给不同的Worker去执行，协调Map、Reduce阶段（执行完所有Map任务之后才可以去执行Reduce任务） Worker执行器：任务执行者，执行Map、Reduce任务 起来一个MR任务后，只会有一个Coordinator进程，可以有多个Worker进程。需要去考虑和解决下面的几个问题\nCoordinator如何感知worker？ 所有Map任务执行完成后，方可进行Reduce任务，Coordinator如何进行协调分配任务？ Map任务会产生临时文件作为输出，需要收集所有的临时文件内容作为Reduce的输入，两种任务之间如何配合？ Worker可能会crash，正在处理的任务该如何处理？ Worker执行任务时间可能过长，如何处理？ 课程前置知识 1、MapReduce的运行机制\n2、Go内置的RPC通信\n3、Go的锁保护机制\n4、Go本地的定时任务time.Ticker 任务运行机制 Coordinator的执行入口在mrcoordinator.go文件中，逻辑就是创建一个Coordinator结构体实例，之后循环执行Done()方法，来判断Coordinator是否已经结束，进而判断整个MR任务是否结束。\nWorker的执行入口在mrworker.go文件中，逻辑就是加载Map、Reduce的函数，之后调用worker的Worker方法。当前Worker进程具体该如何执行Map、Reduce任务，需要自己在Worker方法内区实现。\n实验只需要修改src/mr里边的三个文件，在里边书写自己的逻辑代码\ncoordinator.go worker.go rpc.go 实现设计 这里先明确一下概念，对启动一个MR任务称之为Job，而Map任务、Reduce任务称为Task。后面都用英文来表示。 Coordinator的设计 一个Coordinator需要知道MR Job当前需要处理的files，并且有需要几个Reduce（执行MakeCoordinator�的时候会传入）。\n由于一个job会存在map、Reduce阶段，这里给job设计了几个阶段（状态），用整型来表示。如下\n阶段 阶段值 初始阶段 1 Map阶段 2 Reduce阶段 3 等待Worker下线阶段 4 job结束 5 Coordinator需要知道当前有哪些Worker存在，判断其Worker的存活，进而判断任务是否还在继续执行。所以需要用一个结构体来表是worker节点，判断存活的依据简单的心跳处理。\nCoordinator需要推进map、reduce任务的执行，需要维护task列表。（具体task的设计看下面）这里分别为两种类型的task设立两个列表，使用map存放。\n因为执行完map任务后，才可以执行reduce任务，这里简单起见，判断各个阶段任务完成的标记使用计数来表示。所以而外需要两个统计数值：map任务完成数量、reduce任务完成数量。\n多个Worker请求，需要并发修改task结构体的状态以及统计任务数等，会需要互斥访问，还需要一个mutex进行数据保护。\n总结上述，一个Coordinator内包含的结构如下。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 type Coordinator struct { // Your definitions here. files []string reduceNum int jobStage int workerNodeMap map[int]*workerNode mapTaskMap map[int]*TaskResult reduceTaskMap map[int]*TaskResult mapTaskDoneCount int reduceTaskDoneCount int taskMutex sync.Mutex } type workerNode struct { workerId int lastHeartBeatTime int64 } const JOB_STAGE_INIT = 1 const JOB_MAP_STAGE = 2 const JOB_REDUCE_STAGE = 3 const JOB_END = 5 const MAP_TASK = \u0026#34;map\u0026#34; const REDUCE_TASK = \u0026#34;reduce\u0026#34; Task的设计 mapTask、reduceTask都有很大的相似性，外出来看都是输入、输出。所以这里设计都使用同一个结构体来表示两种阶段的任务。使用一个type字段进行区分即可。这里也给task进行了状态的划分。（这里假设task没有失败的可能）。\n阶段 阶段值 待执行 1 执行中 2 执行完成 3 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 const TASK_PENDING = 1 const TASK_EXECUTING = 2 const TASK_COMPLETED = 3 type TaskResult struct { TaskId int // 由Coordinator进行分配 TaskType string // map or reduce Status int FilePath []string // input file path ResultPath []string // output file path ExecuteSuccess bool // execute result WorkerId int // execute worker NReduce int StartExecuteTime int64 } type HeartbeatResult struct { WorkerId int Shutdown bool // 当true时直接退出进程 } Worker的设计 worker比较简单，主要是和Coordinator进行通信，执行map、reduce任务。\n由于map、reduce类型的task都是worker执行，中间文件的处理也落到了worker身上。下面是处理各个阶段的逻辑\nmap阶段：worker会根据reduce的数量n，创建n个临时文件，并将map产生的kv结果，分散写入到这n个临时文件中。之后，将这n个临时文件路径作为当前map任务的ResultPath，上报给Coordinator。 Coordinator协调阶段：将map产出的临时文件，写入到对应的Reduce任务的FilePath中作为输入 reduce阶段：worker读取所有FilePath中的文件后，做一个sort、merge，执行Reduce函数。将产出写入到mr-out-taskId的文件中（这里简单起见，不写入tmp file了） 这里和实验推荐的一样，将map生成的中间KV数据作为json结构写入到临时文件中。 RPC通信设计 Coordinator和worker之间，是采用不断请求的模式（pull）。Coordinator不会主动给worker发送数据。\n这里设计了三种的接口交互\nworker定时上报心跳给Coordinator worker不断地从Coordinator中获取任务执行 worker执行完一个任务后，上报执行结果给Coordinator 基本如下图所示：\n较重要的定时任务 定时任务主要是解决Worker获取到任务后，但是Worker宕机的情况，这时候Worker执行的task需要交给其他Worker去执行。\n设计上，通过判定Worker的心跳超时时间来判定Worker是否宕机，以及按照实验首页说的，简单的判断如果task执行时间超过了10s，也认为该任务需要切换Worker执行。\n下面是Coordinator的两个定时任务逻辑\n扫描Worker列表，如果上一次心跳时间超过了预定的超时时间，那么就从Worker列表中剔除 扫描task列表，任务处于正在执行中，如果其执行的Worker并不在Worker的列表中，或者执行时间超过了10s，则重置该任务为待执行状态 这样就可以重置Task的状态，存活的Worker就可以获取得到Task执行。\nCoordinator执行阶段推进 在执行完所有的Map任务之后，才可以执行Reduce任务。设计上，将任务推进放到了Coordinator中接受任务执行结果的逻辑中。如果所有的Map任务执行完成了，那么就将JOB_STAGE修改成Reduce阶段，这样Worker就可以获取到Reduce任务去执行。\n只有Coordinator知道整体的完成情况，但是Worker不知道。Worker可以简单的设计为如果RPC调用失败，就认为Coordinator结束了，自己也跟着退出。或者有某种RPC结果能让Worker知道当前需要退出。\n这里设计通过Worker的心跳返回结果来告知Worker下一步的执行，如果收到shutdown命令，那么就直接退出。Coordinator在Reduce阶段结束，就直接走到end阶段。\n踩坑 对于go语言不太熟练，一些常见的坑踩了不少\n切片slice、哈希表map的遍历修改、删除元素 go内置rpc使用，对于默认值是如何处理的（这里对于各种状态，建议避开默认值） 这里有个坑调试了很久，就是worker在去请求任务的时候，创建的TaskResult结构体是放在了for循环外边，导致在导致每次调用获取到的结果会掺杂了上次调用的结果😭，还有默认值不修改的问题。\n下面放点代码示例\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 func getTaskFromCoordinator(workerId int) TaskResult { // 问题就在这里，只创建了一次，内部for循环会共用一个实例，多次请求和掺杂上一次请求的结果 // result := \u0026amp;TaskResult{} for { // 正确应该放在循环里边 result := \u0026amp;TaskResult{} ok := call(\u0026#34;Coordinator.GetTaskToExecute\u0026#34;, \u0026amp;workerId, result) if ok { if result.TaskId \u0026gt; -1 { return *result } time.Sleep(time.Second * 2) } else { log.Fatal(\u0026#34;获取任务失败\u0026#34;) } } } 导致的结果就是如下，明明Coordinator返回的taskId是0，为啥worker收到的taskId是-1？？？\n原因就是上一次请求的结果返回的就是-1，这一次返回的是0，是个默认值，go的rpc是不会传输，也就是不会去修改-1，真是日了狗。所以这里建议对于各种状态、id值的定义不要使用默认值！！！\n总结 这里是假设所有的Task最终在10s内都是会执行完成的，10s未完成则交给别的Worker去执行。实际上，Task的执行是会出现各种各样的情况的。而且，这里设计上每一个输入的file作为一个Map任务，会出现计算倾斜的情况。理想情况下需要平均的进行切分数据，让每个Map任务尽可能的处理相同大小的数据。\n首次接触go语言来写项目，不会的就边搜索别写，效率偏慢些，debug半天。不过主要是要在关键节点输出详细的日志信息，便于观察各种数据结构的具体变更情况。\n附录 课程首页：https://pdos.csail.mit.edu/6.824/index.html\n课程实验说明：https://pdos.csail.mit.edu/6.824/labs/lab-mr.html\n参考 ","date":"2024-03-24T21:37:07+08:00","image":"https://gloryjie.github.io/p/mit6824_lab1/cover_hu4faae92f089e584f7c8e1fb189bc7c34_1938005_120x120_fill_box_smart1_3.png","permalink":"https://gloryjie.github.io/p/mit6824_lab1/","title":"MIT6824实验1-MapReduce设计"},{"content":" 封面壁纸为国漫《仙逆》的女主 李慕婉\n射线法简介 射线法的基本思想是重目标点向一个方向引出一条无限的射线法，统计射线与多边形的边相交的数量\n如果是偶数，则点在多边形外 如果是奇数，则点在多边形内 一般射线的方向是x轴的正数方向。算法的时间复杂度为O(n)，n为多边形的边（点）数。\n情况列举和分享 下面几种情况都算是点在多边形内\n点在多边形内 点和多边形的顶点重叠 点在多边形的边上 射线法将判断在多边形内，转移为判断点和边的关系。所以算法的主要逻辑，就是在判断点射线和边的空间关系。有两种情况需要特殊处理。\n射线经过边的顶点 判断点在斜线的左侧的三角函数 从点引出的射线和多边形的边有下面几种情况需要考虑\n点在在边的上方、下方、右侧，不会相交 边水平的情况，不判断交点数，只判断是否在线上 射线经过边的顶点，则需要使用权重值来解决经过顶点的问题（涵盖了边垂直的情况） B点在A点的下方，那么权重值-0.5 B点在A点的上方，那么权重值+0.5 边垂直的情况 点在垂直的边P上，则点在多边形内 点在在垂直的边的左边，则点与该边必然有交点 边斜线的情况 点在线的左边，肯定会有交点 通过三角函数来判断点是否在边的左边 各种情况的判断代码 点的表达\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 @Data @AllArgsConstructor @NoArgsConstructor public class Point { /** * 经度 */ private Double lng; /** * 纬度 */ private Double lat; } 目标点和多边形的顶点重合\n1 2 3 4 5 6 // 顶点重合的情况 for (Point polygonPoint : polygonPoints) { if (Objects.equals(target, polygonPoint)) { return true; } } 点在的上方、下方、右侧，射线肯定不会和边相交\n1 2 3 4 if (target.getLat() \u0026lt; minLat || target.getLat() \u0026gt; maxLat || target.getLng() \u0026gt; maxLng) { pointA = pointB; continue; } 边水平的情况,若点在水平的边上，则点在多边形内。平行重叠的情况，不做交点数判断。\n1 2 3 4 5 6 7 if (Objects.equals(pointA.getLat(), pointB.getLat())) { if (target.getLng() \u0026lt;= maxLng \u0026amp;\u0026amp; target.getLng() \u0026gt;= minLng) { return true; } pointA = pointB; continue; } 射线经过边的顶点(此时边可能垂直)，解决方案为：如果交点是待测多边形某个边上的一个顶点，则只有当该边的另一个顶点位于射线下方时，交点才算在内。这实际上等同于将与射线相交的顶点视为略高于射线。\n1 2 3 4 5 6 7 8 9 10 11 12 if ((Objects.equals(target.getLat(), pointA.getLat()) \u0026amp;\u0026amp; target.getLng() \u0026lt; pointA.getLng()) || Objects.equals(target.getLat(), pointB.getLat()) \u0026amp;\u0026amp; target.getLng() \u0026lt; pointB.getLng()) { if (pointB.getLat() \u0026lt; pointA.getLat()) { // B点在A点的下方，那么权重值-0.5 intersectPointWeights -= 0.5; } else if (pointB.getLat() \u0026gt; pointA.getLat()) { // B点在A点的上方，那么权重值+0.5 intersectPointWeights += 0.5; } pointA = pointB; continue; } 边垂直的情况\n1 2 3 4 5 6 7 8 9 10 11 12 if (Objects.equals(pointA.getLng(), pointB.getLng())) { if (Objects.equals(target.getLng(), pointA.getLng())) { // 若点在垂直的边P上，则点在多边形内 return true; } else if (target.getLng() \u0026lt; pointA.getLng()) { // 若点在在垂直的边的左边，则点与该边必然有交点 intersectPointCount++; } pointA = pointB; continue; } 边斜线的情况，使用三角函数来判断\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 if (target.getLng() \u0026lt;= minLng) { // 点point的x坐标在边的左侧，那么肯定相交 intersectPointCount++; } else if (target.getLng() \u0026lt; maxLng) { // 点point的x坐标在点B、A的x坐标中间 double diff = (target.getLat() - pointA.getLat()) * (pointA.getLng() - pointB.getLng()) / (pointA.getLat() - pointB.getLat()) + pointA.getLng() - target.getLng(); if (diff \u0026gt;= 0) { if (diff \u0026lt; PRECISION) { // 由于double精度在计算时会有损失，故匹配一定的容差 // 点在斜线P1P2上 return true; } else { // 点向右射线与斜线P1P2有交点 intersectPointCount++; } } } 测试示例 图形如下\n点集合，也就是多边形\n1 [{\u0026#34;lng\u0026#34;:110.269889,\u0026#34;lat\u0026#34;:21.308982},{\u0026#34;lng\u0026#34;:110.277883,\u0026#34;lat\u0026#34;:21.231378},{\u0026#34;lng\u0026#34;:110.275219,\u0026#34;lat\u0026#34;:21.178585},{\u0026#34;lng\u0026#34;:110.309195,\u0026#34;lat\u0026#34;:21.166692},{\u0026#34;lng\u0026#34;:110.345361,\u0026#34;lat\u0026#34;:21.166692},{\u0026#34;lng\u0026#34;:110.345361,\u0026#34;lat\u0026#34;:21.225846},{\u0026#34;lng\u0026#34;:110.37871,\u0026#34;lat\u0026#34;:21.218632},{\u0026#34;lng\u0026#34;:110.416809,\u0026#34;lat\u0026#34;:21.210863},{\u0026#34;lng\u0026#34;:110.41919,\u0026#34;lat\u0026#34;:21.224181},{\u0026#34;lng\u0026#34;:110.419648,\u0026#34;lat\u0026#34;:21.234822},{\u0026#34;lng\u0026#34;:110.385148,\u0026#34;lat\u0026#34;:21.282747},{\u0026#34;lng\u0026#34;:110.351299,\u0026#34;lat\u0026#34;:21.286387},{\u0026#34;lng\u0026#34;:110.269889,\u0026#34;lat\u0026#34;:21.308982}] 测试代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 System.out.println(\u0026#34;图形外，射线和线水平，不在线上：\u0026#34; + RayCastUtil.isPointInPolygon(new Point(110.301195,21.166692), polygonPointList)); System.out.println(\u0026#34;图形内, 射线和线水平，在线上：\u0026#34; + RayCastUtil.isPointInPolygon(new Point(110.319195,21.166692), polygonPointList)); System.out.println(\u0026#34;图形内，射线和线垂直：\u0026#34; + RayCastUtil.isPointInPolygon(new Point(110.319195,21.186692), polygonPointList)); System.out.println(\u0026#34;图形外，射线和线垂直：\u0026#34; + RayCastUtil.isPointInPolygon(new Point(110.219195,21.186692), polygonPointList)); System.out.println(\u0026#34;图形内，经过线顶点：\u0026#34; + RayCastUtil.isPointInPolygon(new Point(110.305361,21.225846), polygonPointList)); System.out.println(\u0026#34;图形外，经过线顶点：\u0026#34; + RayCastUtil.isPointInPolygon(new Point(110.245361,21.225846), polygonPointList)); System.out.println(\u0026#34;图形内，和一条斜线相交：\u0026#34; + RayCastUtil.isPointInPolygon(new Point(110.305361,21.265846), polygonPointList)); System.out.println(\u0026#34;图形外，和一条斜线相交：\u0026#34; + RayCastUtil.isPointInPolygon(new Point(110.245361,21.265846), polygonPointList)); System.out.println(\u0026#34;图形内，和多条线相交：\u0026#34; + RayCastUtil.isPointInPolygon(new Point(110.305361,21.221846), polygonPointList)); System.out.println(\u0026#34;图形外，和多条线相交：\u0026#34; + RayCastUtil.isPointInPolygon(new Point(110.245361,21.221846), polygonPointList)); 完整代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 public class RayCastUtil { private static final double PRECISION = 2e-10; public static boolean isPointInPolygon(Point target, List\u0026lt;Point\u0026gt; polygonPoints) { // 这里不需要首尾相连，有些不需要，这就 if (Objects.equals(polygonPoints.get(0), polygonPoints.get(polygonPoints.size() - 1))) { polygonPoints = polygonPoints.subList(0, polygonPoints.size() - 1); } // 顶点重合的情况 for (Point polygonPoint : polygonPoints) { if (Objects.equals(target, polygonPoint)) { return true; } } // X轴射线与多边形的交点数 int intersectPointCount = 0; // X轴射线与多边形顶点相交的权值 double intersectPointWeights = 0; // pointA -\u0026gt; pointB 代表一条边 Point pointA = polygonPoints.get(0); Point pointB = null; final int pointSize = polygonPoints.size(); for (int i = 1; i \u0026lt;= pointSize; i++) { // for中定义\u0026lt;=以及这里的%取余，是为了关注最后一个节点连接首节点这条边的情况 pointB = polygonPoints.get(i % pointSize); double minLat = Math.min(pointA.getLat(), pointB.getLat()); double maxLat = Math.max(pointA.getLat(), pointB.getLat()); double minLng = Math.min(pointA.getLng(), pointB.getLng()); double maxLng = Math.max(pointA.getLng(), pointB.getLng()); // 目标点在的上方、下方、右侧，那么就不会相交 if (target.getLat() \u0026lt; minLat || target.getLat() \u0026gt; maxLat || target.getLng() \u0026gt; maxLng) { pointA = pointB; continue; } // 边水平的情况,若点在水平的边上，则点在多边形内, if (Objects.equals(pointA.getLat(), pointB.getLat())) { if (target.getLng() \u0026lt;= maxLng \u0026amp;\u0026amp; target.getLng() \u0026gt;= minLng) { return true; } pointA = pointB; continue; } // 边界处理：射线经过边的顶点(此时边可能垂直) if ((Objects.equals(target.getLat(), pointA.getLat()) \u0026amp;\u0026amp; target.getLng() \u0026lt; pointA.getLng()) || Objects.equals(target.getLat(), pointB.getLat()) \u0026amp;\u0026amp; target.getLng() \u0026lt; pointB.getLng()) { if (pointB.getLat() \u0026lt; pointA.getLat()) { // B点在A点的下方，那么权重值-0.5 intersectPointWeights -= 0.5; } else if (pointB.getLat() \u0026gt; pointA.getLat()) { // B点在A点的上方，那么权重值+0.5 intersectPointWeights += 0.5; } pointA = pointB; continue; } // 边垂直的情况 if (Objects.equals(pointA.getLng(), pointB.getLng())) { if (Objects.equals(target.getLng(), pointA.getLng())) { // 若点在垂直的边P上，则点在多边形内 return true; } else if (target.getLng() \u0026lt; pointA.getLng()) { // 若点在在垂直的边的左边，则点与该边必然有交点 intersectPointCount++; } pointA = pointB; continue; } // 边斜的情况 if (target.getLng() \u0026lt;= minLng) { // 点point的x坐标在边的左侧，那么肯定相交 intersectPointCount++; } else if (target.getLng() \u0026lt; maxLng) { // 点point的x坐标在点B、A的x坐标中间 double diff = (target.getLat() - pointA.getLat()) * (pointA.getLng() - pointB.getLng()) / (pointA.getLat() - pointB.getLat()) + pointA.getLng() - target.getLng(); if (diff \u0026gt;= 0) { if (diff \u0026lt; PRECISION) { // 由于double精度在计算时会有损失，故匹配一定的容差 // 点在斜线P1P2上 return true; } else { // 点向右射线与斜线P1P2有交点 intersectPointCount++; } } } pointA = pointB; } return (intersectPointCount + Math.abs(intersectPointWeights)) % 2 != 0; } } 附录 参考 YouTube视频：Checking if a point is inside a polygon is RIDICULOUSLY simple (Ray casting algorithm) - Inside code\n判断点是否在多边形内的Python实现及小应用（射线法）\n维基百科：多边形内的点\n","date":"2024-03-04T20:33:08+08:00","image":"https://gloryjie.github.io/p/%E5%B0%84%E7%BA%BF%E6%B3%95-%E5%88%A4%E6%96%AD%E7%82%B9%E6%98%AF%E5%90%A6%E5%9C%A8%E5%A4%9A%E8%BE%B9%E5%BD%A2%E5%86%85/cover_hue2c682d0e4643ecbc5c998a202920083_1132640_120x120_fill_q75_box_smart1.jpeg","permalink":"https://gloryjie.github.io/p/%E5%B0%84%E7%BA%BF%E6%B3%95-%E5%88%A4%E6%96%AD%E7%82%B9%E6%98%AF%E5%90%A6%E5%9C%A8%E5%A4%9A%E8%BE%B9%E5%BD%A2%E5%86%85/","title":"射线法 判断点是否在多边形内"},{"content":" 1 封面是《死亡搁浅》游戏中的 玛玛 官方有教程：https://resilience4j.readme.io/v1.7.0/docs/getting-started-3\n这里做个简单使用记录。 版本要求 Resilience4j版本 JDK版本 1.7 8 2.0 17 这里用的jdk8，使用Resilience4j的1.7版本。mvn依赖如下\n1 2 3 4 5 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;io.github.resilience4j\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;resilience4j-spring-boot2\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.7.1\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 这个包把Resilience4j的基本组件都引入进来了。\nyml配置 配置可以有三个层级的配置，分别可以继承。\n修改默认配置 自定义可共享的配置 实例自定义配置 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 resilience4j.circuitbreaker: # 指定对应的组件 configs: default: # 修改默认配置 slidingWindowSize: 100 permittedNumberOfCallsInHalfOpenState: 10 waitDurationInOpenState: 10000 failureRateThreshold: 60 eventConsumerBufferSize: 10 registerHealthIndicator: true someShared: # 可共享的配置 slidingWindowSize: 50 permittedNumberOfCallsInHalfOpenState: 10 instances: # 下面是实例自定义配置 backendA: # 实例名称 baseConfig: default # 指定继承的配置 waitDurationInOpenState: 5000 backendB: baseConfig: someShared 事件监听器 Resilience4j提供了两种细粒度的时间监听\nRegistry组件的增、删、替换事件 组件实例的状态变化事件 Resilience4j原生使用时在对应组件实例的基础上去进行设置监听，但是结合SpringBoot之后是没有办法直接拿到对应的组件实例。可以通过监听实例的增、删、替换的动作，进而拿到对应的实例，之后再进行监听实例状态的变更。\n自己创建的RegistryEventConsumer的Bean，会自动添加到SpringBoot自身管理的CircuitBreakerRegistry中。\n以监听CircuitBreaker组件为例，参考代码如下（IMessageService为自己的bean）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 @Bean public RegistryEventConsumer\u0026lt;CircuitBreaker\u0026gt; circuitBreakerEventConsumer(IMessageService messageService){ return new RegistryEventConsumer\u0026lt;CircuitBreaker\u0026gt;() { @Override public void onEntryAddedEvent(EntryAddedEvent\u0026lt;CircuitBreaker\u0026gt; entryAddedEvent) { entryAddedEvent.getAddedEntry().getEventPublisher().onStateTransition(event -\u0026gt; { String circuitBreakerName = event.getCircuitBreakerName(); CircuitBreaker.State fromState = event.getStateTransition().getFromState(); CircuitBreaker.State toState = event.getStateTransition().getToState(); log.info(\u0026#34;CircuitBreaker \u0026#39;{}\u0026#39; changed state from {} to {}\u0026#34;, circuitBreakerName, fromState, toState); StringBuilder builder = new StringBuilder(); builder.append(\u0026#34;\u0026lt;font color=\\\u0026#34;warning\\\u0026#34;\u0026gt;断路器状态发生变化 \u0026#34;).append(DateUtil.now()).append(\u0026#34; \u0026lt;/font\u0026gt;\\n\u0026#34;); builder.append(\u0026#34;\u0026gt; 断路器名称：\u0026#34;).append(circuitBreakerName).append(\u0026#34;\\n\u0026#34;); builder.append(\u0026#34;\u0026gt; 变化前状态：\u0026#34;).append(fromState).append(\u0026#34;\\n\u0026#34;); builder.append(\u0026#34;\u0026gt; 变化后状态：\u0026#34;).append(toState).append(\u0026#34;\\n\u0026#34;); builder.append(\u0026#34;请尽快处理！！！\u0026#34;); messageService.reportDefaultMsg(builder.toString()); }); } @Override public void onEntryRemovedEvent(EntryRemovedEvent\u0026lt;CircuitBreaker\u0026gt; entryRemoveEvent) { } @Override public void onEntryReplacedEvent(EntryReplacedEvent\u0026lt;CircuitBreaker\u0026gt; entryReplacedEvent) { } }; } 使用形式 注解使用 只需要在对应的方法加上对应组件的直接即可。还可以在添加降级处理的方，会自动根据异常类型进行批量。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 @CircuitBreaker(name = BACKEND, fallbackMethod = \u0026#34;fallback\u0026#34;) @RateLimiter(name = BACKEND) @Bulkhead(name = BACKEND, fallbackMethod = \u0026#34;fallback\u0026#34;) @Retry(name = BACKEND) @TimeLimiter(name = BACKEND) public Mono\u0026lt;String\u0026gt; method(String param1) { return Mono.error(new NumberFormatException()); } private Mono\u0026lt;String\u0026gt; fallback(String param1, CallNotPermittedException e) { return Mono.just(\u0026#34;Handled the exception when the CircuitBreaker is open\u0026#34;); } private Mono\u0026lt;String\u0026gt; fallback(String param1, BulkheadFullException e) { return Mono.just(\u0026#34;Handled the exception when the Bulkhead is full\u0026#34;); } private Mono\u0026lt;String\u0026gt; fallback(String param1, NumberFormatException e) { return Mono.just(\u0026#34;Handled the NumberFormatException\u0026#34;); } // 其实也可以写一个通用的，内部if else好了，减少方法的数量 private Mono\u0026lt;String\u0026gt; fallback(String param1, Exception e) { return Mono.just(\u0026#34;Handled any other exception\u0026#34;); } 代码使用 注解都是基于AOP去处理的，通病就是调用内部方法的时候是不会生效的。可以手动获取到对应的实力。\n1 2 3 4 5 @Resource private CircuitBreakerRegistry circuitBreakerRegistry; // 从registry获取实例，和注解使用的是同一个实例 circuitBreakerRegistry.circuitBreaker(\u0026#34;tencentAddressService\u0026#34;); starter的配置过程 结合SpringBoot的starter，流程基本就是读取配置，创建各种Bean组件。提供了各种注解，则过程就是基于Aop去实现的。这里简单看下CircuitBreaker的实现过程。\n基本涉及两个类\nCircuitBreakerConfiguration配置类，负责启动时创建断路器相关的Bean CircuitBreakerAspect切面处理，CircuitBreaker注解的处理 Bean的生成 两个关键的Bean\nCircuitBreakerRegistry CircuitBreakerAspect 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 @Bean @Primary public RegistryEventConsumer\u0026lt;CircuitBreaker\u0026gt; circuitBreakerRegistryEventConsumer( Optional\u0026lt;List\u0026lt;RegistryEventConsumer\u0026lt;CircuitBreaker\u0026gt;\u0026gt;\u0026gt; optionalRegistryEventConsumers) { // 自定义的RegistryEventConsumer会注入进来 return new CompositeRegistryEventConsumer\u0026lt;\u0026gt;( optionalRegistryEventConsumers.orElseGet(ArrayList::new)); } @Bean public CircuitBreakerRegistry circuitBreakerRegistry( EventConsumerRegistry\u0026lt;CircuitBreakerEvent\u0026gt; eventConsumerRegistry, RegistryEventConsumer\u0026lt;CircuitBreaker\u0026gt; circuitBreakerRegistryEventConsumer, @Qualifier(\u0026#34;compositeCircuitBreakerCustomizer\u0026#34;) CompositeCustomizer\u0026lt;CircuitBreakerConfigCustomizer\u0026gt; compositeCircuitBreakerCustomizer) { CircuitBreakerRegistry circuitBreakerRegistry = createCircuitBreakerRegistry( circuitBreakerProperties, circuitBreakerRegistryEventConsumer, compositeCircuitBreakerCustomizer); registerEventConsumer(circuitBreakerRegistry, eventConsumerRegistry); // then pass the map here initCircuitBreakerRegistry(circuitBreakerRegistry, compositeCircuitBreakerCustomizer); return circuitBreakerRegistry; } @Bean @Conditional(value = {AspectJOnClasspathCondition.class}) public CircuitBreakerAspect circuitBreakerAspect( CircuitBreakerRegistry circuitBreakerRegistry, @Autowired(required = false) List\u0026lt;CircuitBreakerAspectExt\u0026gt; circuitBreakerAspectExtList, FallbackDecorators fallbackDecorators, SpelResolver spelResolver ) { return new CircuitBreakerAspect(circuitBreakerProperties, circuitBreakerRegistry, circuitBreakerAspectExtList, fallbackDecorators, spelResolver); } 切面处理逻辑 切面的逻辑比较简单\n看看有没有注解 circuitBreakerRegistry中获取CircuitBreaker实例 是否使用fallback，不同的处理 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 @Pointcut(value = \u0026#34;@within(circuitBreaker) || @annotation(circuitBreaker)\u0026#34;, argNames = \u0026#34;circuitBreaker\u0026#34;) public void matchAnnotatedClassOrMethod(CircuitBreaker circuitBreaker) { } @Around(value = \u0026#34;matchAnnotatedClassOrMethod(circuitBreakerAnnotation)\u0026#34;, argNames = \u0026#34;proceedingJoinPoint, circuitBreakerAnnotation\u0026#34;) public Object circuitBreakerAroundAdvice(ProceedingJoinPoint proceedingJoinPoint, @Nullable CircuitBreaker circuitBreakerAnnotation) throws Throwable { // 方法上有没有注解 Method method = ((MethodSignature) proceedingJoinPoint.getSignature()).getMethod(); String methodName = method.getDeclaringClass().getName() + \u0026#34;#\u0026#34; + method.getName(); if (circuitBreakerAnnotation == null) { circuitBreakerAnnotation = getCircuitBreakerAnnotation(proceedingJoinPoint); } if (circuitBreakerAnnotation == null) { //because annotations wasn\u0026#39;t found return proceedingJoinPoint.proceed(); } // spel相关的 String backend = spelResolver.resolve(method, proceedingJoinPoint.getArgs(), circuitBreakerAnnotation.name()); io.github.resilience4j.circuitbreaker.CircuitBreaker circuitBreaker = getOrCreateCircuitBreaker( methodName, backend); Class\u0026lt;?\u0026gt; returnType = method.getReturnType(); String fallbackMethodValue = spelResolver.resolve(method, proceedingJoinPoint.getArgs(), circuitBreakerAnnotation.fallbackMethod()); // 没有fallback if (StringUtils.isEmpty(fallbackMethodValue)) { return proceed(proceedingJoinPoint, methodName, circuitBreaker, returnType); } // 有fallback FallbackMethod fallbackMethod = FallbackMethod .create(fallbackMethodValue, method, proceedingJoinPoint.getArgs(), proceedingJoinPoint.getTarget()); return fallbackDecorators.decorate(fallbackMethod, () -\u0026gt; proceed(proceedingJoinPoint, methodName, circuitBreaker, returnType)).apply(); } 附录 参考 官方教程 How to configure to events in Resilience4j Spring starter ","date":"2024-02-02T11:18:46+08:00","image":"https://gloryjie.github.io/p/resilience4j-%E6%95%B4%E5%90%88springboot/cover_hu3163765b57fc9a9b6b4dbc88ef7da476_2717844_120x120_fill_q75_box_smart1.jpg","permalink":"https://gloryjie.github.io/p/resilience4j-%E6%95%B4%E5%90%88springboot/","title":"Resilience4j-整合Springboot"},{"content":" 交友：扩充圈子，多认识妹子，多花时间进行线上交流；舍得花钱打扮 阅读：非技术书籍20+本，技术书籍10+，网文1本 运动：践行干净增肌，8个月增肌、3个月减脂，目标65kg 游戏：打完5+游戏，死亡搁浅、只狼、艾尔登法环、ffe7等 技术提升：基础增强（网络、操作系统）、算法LC刷题100道、接触AIGC 技术课程：至少一门国外课程（看完并做完实验），例如MIT6.824、MIT6.S081 项目实践：设计一个个人项目并上线运行 投资理财：继续学习相关知识，在尽可能不增加资金的情况下，回本！ 生活体验：出行游玩，如武功山、武汉、九寨沟 新技能：手机摄影\u0026amp;剪辑 习惯养成目标\n12点前入睡，7点起 行路中，不玩手机 每周进行总结 每月1~2本书 降低拖延症 ","date":"2024-01-04T17:47:55+08:00","image":"https://gloryjie.github.io/p/2024%E5%B9%B4%E5%BA%A6%E8%AE%A1%E5%88%92/cover_hu6b62954a64c9532f0495ca1fd21ae92d_130115_120x120_fill_box_smart1_3.png","permalink":"https://gloryjie.github.io/p/2024%E5%B9%B4%E5%BA%A6%E8%AE%A1%E5%88%92/","title":"2024年度计划"}]