[{"content":" 封面为《不良人》第六季中的尸祖降臣\nES常见的应用场景就是搜索，大多数业务系统的数据迁移到ES后，大都是等值、范围、like等，并未使用到match查询，相当于把ES搜索当做MySQL来使用。本文不会涉及到分词、搜索打分等场景，更倾向于常用数据的搜索。\n业务服务和ES的交互方式 如何使用ES，会影响到Mapping的设计原则。在实践过程中，仅仅是把ES当做ID的筛选器。\n在数据同步阶段，只把需要搜索的字段同步到es中，降低单个文档的大小 搜索阶段，通过es进行搜索，查询出id的集合，之后通过该id集合从MySQL中获取原始的数据源 流程的示意图如下\nES的搜索流程中，有两个阶段：search、fetch。\nsearch阶段是从分片中搜索并获取相应文档id和其排序数据，在协调节点处理，生成结果集id fetch阶段是将对应的结果集id，从id对应分片中获取实际的文档数据 从上述流程中，可以看到，只使用到了search阶段，而fetch阶段替换成业务服务自行获取。\n这个方案的优点就是数据实时性高，可以规避ES数据滞后问题。\n排序问题 根据id批量从MySQL中获取数据，返回的顺序会错乱，所以需要根据原id的顺序进行调整即可。\nmapping设计 mapping设计好，可以减少不必要的计算和写入，降低索引大小。\n禁用Dynamic Mapping 动态映射在创建索引时有三种配置值，至少设置为false。\n可选值 含义 true 自动添加到mapping中，并且支持索引和搜索 runtime 新字段将会被作为runtime类型的filed false 不会添加到mapping中，不支持索引和搜索。不过仍然会保存在_source中。 strict 如果发现新的field，会抛出异常 必须明确每个字段的数据类型，和其对应的属性配置，就类似于SQL的建表，严格确定结构。对于字段数据类型和其支持的属性配置，需要对ES有一定的熟悉程度，可以参考es的文档来进行设置，一般来说明确数据类型即可。\n选择合适的数据类型 明确数据类型的时候，需要选择合适的数据类型，例如字符串类型的id、状态枚举等明确的值，选择keyword而不是text。\n字段尽量少 字段尽可能少，最好做到只保留需要参与检索的字段。因为es需要提前构建倒排索引，所以字段越多，写入的时候占用的资源就越多，相同的 index buffer 能存储的数据条数越少。\n这也和对ES的应用方式有关，在实践中，先利用ES检索出文档id，之后根据id从原始数据源MySQL中获取文档数据。\n不需要的搜索的字段不要索引 不需要搜索的字段，如果还是需要同步到es中，那么可以将其指定为非搜索字段。将字段的Index属性设置为false即可，每个字段都会有该属性。可以降低es写入时的处理逻辑。\n1 2 3 4 5 6 7 8 9 10 11 12 PUT myindex { \u0026#34;mappings\u0026#34;: { \u0026#34;properties\u0026#34;: { \u0026#34;content\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;text\u0026#34; }, \u0026#34;name\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;text\u0026#34;, \u0026#34;index\u0026#34;: false } } } } 结构扁平化 尽量减少 object 类型的使用，更建议将数据扁平化。越是复杂的数据结构，系统要处理的事情就越多，写入就越慢。而且 nested、parent-child 等数据类型，在查询时候性能也很差。\n常见场景应用字段类型 对于业务系统来说，设计表的字段的场景不是很多，会有一些常见的场景。这里列一些常见场景设计的字段，以及对应的es数据类型。\n场景值 字段类型 id值、状态枚举、类型枚举 keyword 日期、时间、时间戳等 date 价格（转成分存储） long 日期时间范围（常见预约时间等场景） date_range 短字符（如名称等like查询场景） wildcard 这里比较特别的就是使用wildcard类型，来解决模糊匹配的场景，对应的就是SQL中的like。该数据类型是7.9版本提供的，对于wildcard类型的性能问题可以参考：Elasticsearch 查询革新：探索 Wildcard 类型的高效模糊匹配策略。\n总结 当前对于ES的应用，还是处于比较简单的水平，解决一些复杂查询和聚合查询的场景，缓解MySQL的压力。查询条件也是基本和MySQL区别不是太大，大都是等值、范围、like等。 而对于ES擅长的全文搜索、文档评分等功能，当前业务场景并未使用过。等待后续继续探索。\n附录 参考 ES小册：35.唯快不破：写调优\nElasticsearch 查询革新：探索 Wildcard 类型的高效模糊匹配策略\n","date":"2024-12-07T11:08:38+08:00","image":"https://gloryjie.github.io/p/es%E5%BA%94%E7%94%A8%E5%AE%9E%E8%B7%B5/cover_hu02aa61ae1d9de35cbe238d2676170cb9_782219_120x120_fill_q75_box_smart1.jpeg","permalink":"https://gloryjie.github.io/p/es%E5%BA%94%E7%94%A8%E5%AE%9E%E8%B7%B5/","title":"Es应用实践指南"},{"content":" 封面为《凡人修仙传》118集元瑶出浴，现在已经被剪掉了\n了解了基础的状态机概念后，来实现一个简单的状态机，包含几大组件：状态State、转变Transition、事件Event、动作Action、守护条件Condition等概念组件。\n状态State 表示状态可以是int、string、enum等类型的值，所以定义一个接口，获取泛型的值。\n1 2 3 4 5 public interface FsmState\u0026lt;T\u0026gt; { T value(); } 事件Event 事件和State类似的，都可以用int、string、enum等表示。\n1 2 3 4 5 public interface FsmEvent\u0026lt;T\u0026gt; { T value(); } 事件和状态的三元组 定义一个三元组，来描述当前状态，发生了什么事情，目标状态是什么。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 @Getter @AllArgsConstructor public class FsmTransitionUnit\u0026lt;S,E\u0026gt; { /** * 现态 */ private FsmState\u0026lt;S\u0026gt; sourceState; /** * 关联的事件 */ private FsmEvent\u0026lt;E\u0026gt; event; /** * 次态 */ private FsmState\u0026lt;S\u0026gt; targetState; } 状态流转上下文 当发生了事件后，会触发状态流转Transition，而Transition中需要感知到当前的上下文情况\n当前状态是什么sourceState 发生了什么事情Event 流转到的目标状态是什么targetState 除了状态机本身需要的上下文外，还允许携带一些自定义的上下文数据对象 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 public interface FsmStateContext\u0026lt;S, E, C\u0026gt; { /** * 当前状态 */ FsmState\u0026lt;S\u0026gt; sourceState(); /** * 次态（目标状态） */ FsmState\u0026lt;S\u0026gt; targetState(); /** * 触发事件 */ FsmEvent\u0026lt;E\u0026gt; event(); /** * 自定义上下文对象 */ C context(); } 状态流转Transition 状态流转Transition其实是多个动作的组合\nonCondition：根据上下文判断是否可以执行Action，可以没有 onAction：执行具体的Action afterAction：执行完Action之后可以做一些后置处理，可以没有 可以看到这三个方法的参数都是FsmStateContext，可以获取到状态机自身的状态情况，以及自定义的上下文数据对象。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 public interface FsmStateTransition\u0026lt;S, E, C\u0026gt; { /** * 执行动作之前，判断状态是否运行执行 * * @return 是否可以执行transition */ default boolean onCondition(FsmStateContext\u0026lt;S, E, C\u0026gt; fsmStateContext) { return true; } /** * 实际的动作执行 */ void onAction(FsmStateContext\u0026lt;S, E, C\u0026gt; fsmStateContext); /** * action执行完成之后的处理, 做一些收尾动作 */ default void afterAction(FsmStateContext\u0026lt;S, E, C\u0026gt; fsmStateContext) { } } 状态机StateMachine 状态机实例主要负责两个功能\n提前配置好相关状态之间的流转关系 触发某事件来进行状态流转 1 2 3 4 5 6 7 8 9 10 11 12 13 public interface FsmStateMachine\u0026lt;S, E\u0026gt; { /** * 注册转换Transition */ void registerTransition(FsmTransitionUnit\u0026lt;S, E\u0026gt; transitionUnit, FsmStateTransition\u0026lt;S, E, ?\u0026gt; transition); /** * 触发状态变更的事件 */ boolean fireEvent(FsmState\u0026lt;S\u0026gt; sourceState, FsmEvent\u0026lt;E\u0026gt; event, Object context); } 一个简易状态机的实现类比较简单，主要是在状态机内部需要维护状态流转的关系，下面是几个设计关键点\n这里把\u0026lt;sourceState, event \u0026gt;拼接起来做为一个key，来唯一标识一个Transition 而外维护一个\u0026lt;sourceState, event\u0026gt; 到 targetState的关系 内部简单实现了FsmStateContext，不对外暴露具体的实现 具体代码如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 public class DefaultStateMachine\u0026lt;S, E\u0026gt; implements FsmStateMachine\u0026lt;S, E\u0026gt; { private static final String SEPARATOR = \u0026#34;_TO_\u0026#34;; ConcurrentHashMap\u0026lt;String, FsmStateTransition\u0026lt;S, E,?\u0026gt;\u0026gt; stateTransitionMap = new ConcurrentHashMap\u0026lt;\u0026gt;(); ConcurrentHashMap\u0026lt;String, FsmState\u0026lt;S\u0026gt;\u0026gt; targetStateMap = new ConcurrentHashMap\u0026lt;\u0026gt;(); @Override public synchronized void registerTransition(FsmTransitionUnit\u0026lt;S, E\u0026gt; transitionUnit, FsmStateTransition\u0026lt;S, E, ?\u0026gt; transition) { Objects.requireNonNull(transitionUnit, \u0026#34;transitionUnit cannot be null\u0026#34;); Objects.requireNonNull(transition, \u0026#34;transition cannot be null\u0026#34;); Objects.requireNonNull(transitionUnit.getSourceState(), \u0026#34;sourceState cannot be null\u0026#34;); Objects.requireNonNull(transitionUnit.getEvent(), \u0026#34;event cannot be null\u0026#34;); Objects.requireNonNull(transitionUnit.getTargetState(), \u0026#34;targetState cannot be null\u0026#34;); String key = transitionUnit.getSourceState().value().toString() + SEPARATOR + transitionUnit.getEvent().value().toString(); if (stateTransitionMap.containsKey(key)) { throw new IllegalArgumentException(\u0026#34;transitionUnit already registered\u0026#34;); } stateTransitionMap.put(key, transition); targetStateMap.put(key, transitionUnit.getTargetState()); } @Override public boolean fireEvent(FsmState\u0026lt;S\u0026gt; sourceState, FsmEvent\u0026lt;E\u0026gt; event, Object context) { Objects.requireNonNull(sourceState, \u0026#34;sourceState cannot be null\u0026#34;); Objects.requireNonNull(event, \u0026#34;event cannot be null\u0026#34;); String key = sourceState.value().toString() + SEPARATOR + event.value().toString(); FsmStateTransition stateTransition = stateTransitionMap.get(key); if (stateTransition == null) { return false; } FsmState\u0026lt;S\u0026gt; targetState = targetStateMap.get(key); DefaultStateContext\u0026lt;S, E, Object\u0026gt; contextImpl = new DefaultStateContext\u0026lt;\u0026gt;(sourceState, targetState, event, context); boolean conditionResult = stateTransition.onCondition(contextImpl); if (conditionResult) { stateTransition.onAction(contextImpl); stateTransition.afterAction(contextImpl); return true; } return false; } @AllArgsConstructor static class DefaultStateContext\u0026lt;S,E, C\u0026gt; implements FsmStateContext\u0026lt;S,E, C\u0026gt; { private FsmState\u0026lt;S\u0026gt; source; private FsmState\u0026lt;S\u0026gt; target; private FsmEvent\u0026lt;E\u0026gt; event; private C context; @Override public FsmState\u0026lt;S\u0026gt; sourceState() { return source; } @Override public FsmState\u0026lt;S\u0026gt; targetState() { return target; } @Override public FsmEvent\u0026lt;E\u0026gt; event() { return event; } @Override public C context() { return context; } } } 实践demo 基于支付单的模型来，在上述设计上做个实践demo。\n支付单的状态设计：初始、待支付、已支付、已退款、已取消\n1 2 3 4 5 6 7 8 9 public enum StateEnum implements FsmState\u0026lt;StateEnum\u0026gt; { INIT, WAIT_PAY, PAYED, REFUND, CANCEL; @Override public StateEnum value() { return this; } } 支付单相关事件：创建事件、支付事件、取消时间、退款事件\n1 2 3 4 5 6 7 8 9 10 11 12 public enum EventEnum implements FsmEvent\u0026lt;EventEnum\u0026gt; { CREATE_EVENT, PAY_EVENT, CANCEL_EVENT, REFUND_EVENT; @Override public EventEnum value() { return this; } } 定义各种Transition，这里以处理支付事件为例，其余的都类似，只是简单打印日志\n1 2 3 4 5 6 7 8 9 @Slf4j public class PayedTransition implements FsmStateTransition\u0026lt;StateEnum, EventEnum, String\u0026gt; { @Override public void onAction(FsmStateContext\u0026lt;StateEnum, EventEnum, String\u0026gt; fsmStateContext) { log.info(\u0026#34;orderNo={} pay success\u0026#34;, fsmStateContext.context()); } } 接下来初始化StateMachine实例，并配置状态流转过程，简单的说就是配置4个元素\n当前状态 发生的事件 目标状态 需要执行的动作 1 2 3 4 5 FsmStateMachine\u0026lt;StateEnum, EventEnum\u0026gt; fsmStateMachine = new DefaultStateMachine\u0026lt;\u0026gt;(); fsmStateMachine.registerTransition(new FsmTransitionUnit\u0026lt;\u0026gt;(StateEnum.INIT, EventEnum.CREATE_EVENT, StateEnum.WAIT_PAY), new CreatePayOrderTransition()); fsmStateMachine.registerTransition(new FsmTransitionUnit\u0026lt;\u0026gt;(StateEnum.WAIT_PAY, EventEnum.PAY_EVENT, StateEnum.PAYED), new PayedTransition()); fsmStateMachine.registerTransition(new FsmTransitionUnit\u0026lt;\u0026gt;(StateEnum.WAIT_PAY, EventEnum.CANCEL_EVENT, StateEnum.CANCEL), new CancelTransition()); fsmStateMachine.registerTransition(new FsmTransitionUnit\u0026lt;\u0026gt;(StateEnum.PAYED, EventEnum.REFUND_EVENT, StateEnum.REFUND), new RefundTransition()); 接下来触发事件\n1 2 3 4 5 6 7 8 9 10 11 // 正常的状态流转 fsmStateMachine.fireEvent(StateEnum.INIT, EventEnum.CREATE_EVENT, \u0026#34;12345678\u0026#34;); fsmStateMachine.fireEvent(StateEnum.WAIT_PAY, EventEnum.PAY_EVENT, \u0026#34;12345678\u0026#34;); fsmStateMachine.fireEvent(StateEnum.WAIT_PAY, EventEnum.CANCEL_EVENT, \u0026#34;12345678\u0026#34;); fsmStateMachine.fireEvent(StateEnum.PAYED, EventEnum.REFUND_EVENT, \u0026#34;12345678\u0026#34;); // 异常流转 boolean res = fsmStateMachine.fireEvent(StateEnum.INIT, EventEnum.REFUND_EVENT, \u0026#34;12345678\u0026#34;); if (!res) { log.error(\u0026#34;This event={} should not occur in the state={}\u0026#34;, EventEnum.REFUND_EVENT,StateEnum.INIT); } 能够正常流转的状态，都通过Transition执行并打印了日志。\n1 2 3 4 5 10:37:56.810 [main] INFO com.example.stateMachine.test.CreatePayOrderTransition - orderNo=12345678 pay order create success 10:37:56.812 [main] INFO com.example.stateMachine.test.PayedTransition - orderNo=12345678 pay success 10:37:56.812 [main] INFO com.example.stateMachine.test.CancelTransition - orderNo=12345678 cancel success 10:37:56.812 [main] INFO com.example.stateMachine.test.RefundTransition - orderNo=12345678 refund success 10:37:56.812 [main] ERROR com.example.stateMachine.test.StateMachineTest - This event=REFUND_EVENT should not occur in the state=INIT 总结 基于有限状态机FSM的基础概念来实现一个简单的状态机，囊括了基本的功能：State、Event、Transition、Condition、Action等，可以实现基本的状态流转。这里还是缺少了一些东西，如InternalTransition，更多类型的Action等。在状态机配置上，缺少了一些语义化层面的东西，不够直观。后边会对SpringStateMachine、COLAStateMachine进行介绍。\n附录 参考 ","date":"2024-09-15T09:41:29+08:00","image":"https://gloryjie.github.io/p/%E7%8A%B6%E6%80%81%E6%9C%BA%E7%AF%87%E4%BA%8C%E7%AE%80%E6%98%93%E7%8A%B6%E6%80%81%E6%9C%BA%E5%AE%9E%E7%8E%B0/cover_hu47e7782123627053c1d5b077eb2da475_2213880_120x120_fill_box_smart1_3.png","permalink":"https://gloryjie.github.io/p/%E7%8A%B6%E6%80%81%E6%9C%BA%E7%AF%87%E4%BA%8C%E7%AE%80%E6%98%93%E7%8A%B6%E6%80%81%E6%9C%BA%E5%AE%9E%E7%8E%B0/","title":"状态机篇二：简易状态机实现"},{"content":" 封面来自《诛仙》48集，陆雪琪\n某天，朋友问事务怎么失效了，注解和手动事务都试过了，而且debug走代码确实走到了Spring的事务注解拦截器里边了。和他探讨了一下，原来是他项目配置了多个可写数据源的原因。这种情况自己确实没有遇到过，遂记录一下。\n环境\u0026amp;数据准备 这里使用的环境如下\nJDK17 SpringBoot3.3.3 pom依赖如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-web\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.mysql\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mysql-connector-j\u0026lt;/artifactId\u0026gt; \u0026lt;scope\u0026gt;runtime\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.projectlombok\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;lombok\u0026lt;/artifactId\u0026gt; \u0026lt;optional\u0026gt;true\u0026lt;/optional\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-test\u0026lt;/artifactId\u0026gt; \u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.mybatis.spring.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mybatis-spring-boot-starter\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.0.3\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 先创建两个库\n创建库testA，创建表user 创建库testB，创建表addr 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 create table user ( id bigint auto_increment comment \u0026#39;主键ID\u0026#39; primary key, name varchar(30) null comment \u0026#39;姓名\u0026#39;, age int null comment \u0026#39;年龄\u0026#39;, email varchar(50) null comment \u0026#39;邮箱\u0026#39; ); create table addr ( id int auto_increment primary key, uid int null, address varchar(128) null ); INSERT INTO testA.user (id, name, age, email) VALUES (1, \u0026#39;JOJO\u0026#39;, 22, \u0026#39;123@abc.com\u0026#39;); INSERT INTO testB.addr (id, uid, address) VALUES (1, 1, \u0026#39;广东省XXX市\u0026#39;); Mybatis自动化配置 先看下Mybatis的自动化配置是怎样的 Mybatis的自动化配置只支持单一的数据源，并且构建了两个重要的组件：SqlSessionFactory、SqlSessionTemplate。若配置多数据源的话，需要自己创建这两个组件。\n在使用过程中，通常会在SpringBoot的启动类上加@MapperScan的注解，会扫描Mapper接口，生成对应的代理实现类。这里边有两个属性比较重要：sqlSessionFactoryRef、sqlSessionTemplateRef，可以指定生成的代理实现类所使用的SqlSessionFactory、SqlSessionTemplate实例。\n在和SpringBoot整合的时候，只需要指定sqlSessionTemplate即可，因为该类就是Mybatis-Spring包中适配Spring环境的。\n多数据源配置 自定义数据源配置Mybatis，可以跟着MybatisAutoConfiguration来自己写配置，并且通过@MapperScan来指定对应的Mapper代理使用的SqlSessionTemplate实例。@MapperScan 是根据包来扫描的，所以我们的Mapper需要根据DataSource来分package。\n除了Mybatis的配置外，我们还需要进行SpringBoot的TransactionManager配置，是和DataSource关联的，如果配置了多个DataSource，那么就要相对应的配置对应的TransactionManager。\n下来看下yml的配置，没什么特别的，只是配置两个数据源\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 spring: application: name: spring-demo datasource: user: type: com.zaxxer.hikari.HikariDataSource driver-class-name: com.mysql.cj.jdbc.Driver jdbcUrl: jdbc:mysql://localhost:3306/testA username: root password: 123456 addr: type: com.zaxxer.hikari.HikariDataSource driver-class-name: com.mysql.cj.jdbc.Driver jdbcUrl: jdbc:mysql://localhost:3306/testB username: root password: 123456 接下来就要对DataSource、SqlSessionFactory、SqlSessionTemplate、@MapperScan进行配置了。先来看看user库的配置，这里把他作为Primary。对于Mybatis的众多配置，如xml的扫描路径、插件配置等，都可以在构建SqlSessionFactory的方法内进行。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 @Configuration @MapperScan(value = \u0026#34;com.example.springdemo.mapper.user\u0026#34;, sqlSessionTemplateRef = \u0026#34;userSqlSessionTemplate\u0026#34;) public class UserDataSourceConfig { @Primary @Bean(\u0026#34;userDataSource\u0026#34;) @ConfigurationProperties(prefix = \u0026#34;spring.datasource.user\u0026#34;) public DataSource userDataSource() { return DataSourceBuilder.create().build(); } @Primary @Bean public PlatformTransactionManager userTransactionManager(@Qualifier(\u0026#34;userDataSource\u0026#34;) DataSource dataSource) { return new JdbcTransactionManager(dataSource); } @Primary @Bean public SqlSessionFactory userSqlSessionFactory(@Qualifier(\u0026#34;userDataSource\u0026#34;) DataSource dataSource) throws Exception { SqlSessionFactoryBean sqlSessionFactoryBean = new SqlSessionFactoryBean(); sqlSessionFactoryBean.setDataSource(dataSource); return sqlSessionFactoryBean.getObject(); } @Primary @Bean public SqlSessionTemplate userSqlSessionTemplate(@Qualifier(\u0026#34;userSqlSessionFactory\u0026#34;) SqlSessionFactory sqlSessionFactory) { return new SqlSessionTemplate(sqlSessionFactory); } } 同样的，进行addr数据源的相关配置，不同在于这里也没有Primary。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 @Configuration @MapperScan(value = \u0026#34;com.example.springdemo.mapper.addr\u0026#34;, sqlSessionTemplateRef = \u0026#34;addrSqlSessionTemplate\u0026#34;) public class AddrDataSourceConfig { @Bean(\u0026#34;addrDataSource\u0026#34;) @ConfigurationProperties(prefix = \u0026#34;spring.datasource.addr\u0026#34;) public DataSource addrDataSource() { return DataSourceBuilder.create().build(); } @Bean public PlatformTransactionManager addrTransactionManager( @Qualifier(\u0026#34;addrDataSource\u0026#34;) DataSource dataSource) { return new JdbcTransactionManager(dataSource); } @Bean public SqlSessionFactory addrSqlSessionFactory(@Qualifier(\u0026#34;addrDataSource\u0026#34;) DataSource dataSource) throws Exception { SqlSessionFactoryBean sqlSessionFactoryBean = new SqlSessionFactoryBean(); sqlSessionFactoryBean.setDataSource(dataSource); // 这里进行Mybatis配置 return sqlSessionFactoryBean.getObject(); } @Bean public SqlSessionTemplate addrSqlSessionTemplate(@Qualifier(\u0026#34;addrSqlSessionFactory\u0026#34;) SqlSessionFactory sqlSessionFactory) { return new SqlSessionTemplate(sqlSessionFactory); } } 这里需要注意了，@MapperScan注解上的value，也就是basePackage的值，是指定了不同目录的，不同数据源的Mapper要通过不同的包进行归类，不同放在一起。 测试配置 接下来进行测试，这里引入了web项目，开了两个查询接口。下面是IDEA的http配置\n1 2 3 4 5 ### GET http://localhost:8080/user/1 ### GET http://localhost:8080/addr/1 分别调用这俩接口的时候，获取的数据都是正常的，可以看到日志的打印，分别启动了两个数据源。 至此，两个数据源的配置完成。\n事务失效的场景 如果一个方法同时修改两个数据源，单数据源事务不生效很正常，涉及到分布式事务了。这里主要探讨分析的是更新单个数据源事务失效的情况。\n基于上述配置，更新看下下面的示例代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 // 多数据源更新 @Transactional public void updateInfo() { // 这个会回滚 userMapper.update(); // 这个不会回滚 addrMapper.update(); throw new RuntimeException(\u0026#34;test rollback\u0026#34;); } // 单数据源更新 @Transactional public void updateInfo() { // 这个不会回滚 addrMapper.update(); throw new RuntimeException(\u0026#34;test rollback\u0026#34;); } 示例代码中事务都是失效的的，两个数据已经发生了变更，回滚不生效。下面以第二个更新单个数据源的示例来分析下原因。 先回顾下配置\n主数据源是user，主事务管理器是userTransactionManager 还有数据源addr，其对应的事务管理器为addrTransactionManager 在事务注解@Transactional未指定事务管理器的情况下，使用默认的事务管理器userTransactionManager ，也就是使用的是user的数据源。那么updateInfo方法开启的就是user数据源的事务。然而\naddrMapper使用的是addr数据源，自己的独立事务 在执行到手动抛出异常的时候，addrMapper.update所属数据源addr的事务已经提交了，但是user的事务还在进行中，当抛出异常的时候，Spring会捕获该异常并且回滚user的事务。这就是事务失效的原因，为解决这个问题，需要在事务注解指定事务管理器\n@Transactional(value = \u0026ldquo;addrTransactionManager\u0026rdquo;)\n总结事务失效的场景就是：事务注解使用的事务管理器要和方法内部操作的数据源对应，否则事务不生效。\n总结 SpringBoot+Mybatis的多数据源配置演示完成了，主要是需要配置如下组件\nDataSource TransactionManager SqlSessionFactory SqlSessionTemplate 除了这四个组件外，并且在Mapper的使用上，需要根据数据源进行分package，并且事务注解@Transactional需要指定事务管理器。\n这种配置方式，有个很明显的缺点：有多少个数据源，就得实现多少套组件的配置，并且Mapper要分别存放，事务注解要指定事务管理器。这个一看就很繁琐，在实际应用中这种方式比较少见，毕竟同时写多个数据源在实际中就应该避免，否则就涉及到分布式事务了。\nSpring提供了一个抽象类AbstractRoutingDataSource来更好的支持多数据源的配置，这个下一篇会进行描述。\n附录 参考 ","date":"2024-09-03T11:51:02+08:00","image":"https://gloryjie.github.io/p/springboot%E5%A4%9A%E6%95%B0%E6%8D%AE%E6%BA%90%E9%85%8D%E7%BD%AE%E4%B8%80mybatis%E7%AF%87/cover_hub9c213921ac58281659a82486216fa8d_2043476_120x120_fill_box_smart1_3.png","permalink":"https://gloryjie.github.io/p/springboot%E5%A4%9A%E6%95%B0%E6%8D%AE%E6%BA%90%E9%85%8D%E7%BD%AE%E4%B8%80mybatis%E7%AF%87/","title":"SpringBoot多数据源配置（一）：Mybatis篇"},{"content":" 封面来自《诛仙》48集，陆雪琪\n状态通常是用来描述一个事务当前是处于一个什么阶段（状态），在日常生活中最常见的就是电气的开关状态了，如空调、风扇开关灯。而在通常的项目设计中都会应用到，最常见的就是订单状态了：待支付、已支付、已取消等状态。\n有限状态机（Finite-state Machine，FSM），是表示有限个状态以及在这些状态之间的转移和动作等行为的数学计算模型。就是对现实事物运行状态管理进行抽象，形成了一套状态机的概念。\n基础概念 FSM有非常多的概念，这里介绍几个核心的概念。状态机基础概念概括如下图所示（源自COLA状态机文章） 状态State 状态这个概念就很好理解了，就是当前事务处于一个什么状态。在状态机中，至少需要2个状态，毕竟只有一个状态根本就不需要流转，也不需要管理了。 有限的状态集合里边，事物必须包含一个起点，也就是必须具有初始状态（Initial State），而终态（End State）不是必须的。\n状态转变Transition 状态的切换：原状态过度到目标状态，这个转变过程称之为Transition。状态的转变通常是由触发器引起的，这里的触发器一种抽象，可以是定时器、各种事件等。（其实超时也可以理解成事件）。 但是如果发生了某些事件但是原状态和目标状态是一致的，没有引起状态的Transition。这种场景还是挺常见的，例如订单收货地址的变更，这个动作并不会驱动订单状态的变化。那么是否可以继续使用这个抽象？\n为了区分这两种情况，定义了两种的Transition\n内部转变（InternalTransition）：同一状态的流转 外部转变（ExternalTransition）：两个不同状态之间的流转 事件Event 事件是驱动状态切换的最常见的方式，简单的说就是发生了某些事情，会触发状态变更。例如，用户已经支付了订单，此时订单需要由待支付转变成已支付的状态。\n动作Action 动作Action是更加具体的行为，例如如何实现来实现Transition，状态发生转变后可能需要做点其他事情，如发短信之类的动作。 可以理解为原状态到目标状态的Transition是由多个Action组成的\n转移动作（Transition Actions）：在状态转移过程中执行的动作。 进入动作（Entry Actions）：在进入某个状态时执行的动作。 退出动作（Exit Actions）：在退出某个状态时执行的动作。 守护条件Condition Condition是对\u0026lt;状态，事件\u0026gt;这个二元组的拓展，该条件通过计算返回布尔值。当通过这个二元组来定位到多个Transition的时候，就需要这个Condition来动态决定选择特定的Transition来实现状态的转换。 当二元组值定位到一个Condition的时候，可以把Condition理解为是否允许到达某个状态。\n状态流转过程 状态机对状态进行统一的管理，状态机就需要知道状态是怎么流转的，哪些状态可以流转到哪些状态，例如待支付可以流转到已支付，但是不能够流转到已退款等，所以需要一个提前配置状态机的过程。简单的配置就是四元组：\n\u0026lt;当前状态，事件，目标状态，转换过程Transition\u0026gt;\n当前事务的初始状态状态（Current State），发生了某个事件（Event），触发了转换过程（Transition）来实现流转状态到目标状态（Target State）。\n配置好后，就等待事件来触发某单个事物的状态流转。状态机实现状态的流转逻辑也比较简单，首先是事物（例如某笔订单）肯定发生了某个事件，之后根据该事物的当前状态，就构成了一个二元组：\n\u0026lt;当前状态，事件\u0026gt;\n状态机根据配置就可以找到对应的目标状态（Target State）以及转换（Transition），状态机通过执行该Transition的Action来实现状态的流转。如果找不到该目标状态和Transition，代表无法进行状态流转。\n复杂概念 在UML State Machine的描述中，还有许多复杂的概念，如：层级状态机（Hierarchical State Machines），状态的嵌套（substate），状态的并行（parallel，fork，join），区域（Region）等等。这些概念都非常复杂，现实中还未接触过，理解不深，就不在这里解释描述了。 可以参考下面的文档：\nSpringStateMachine文档：state-machine-concepts（看其附录） UML State Machine 总结 有限状态机把状态管理相关的行为抽象成：状态State、转变Transition、事件Event、动作Action、守护条件Condition等概念。通过对状态机进行配置，来描述状态及事件触发的流转路线，以及实现流转的Transition。 应用状态机，主要是为了对状态进行集中管理，明确状态的流转，避免流转代码的散乱，进而提高了可维护性。\n附录 参考 维基百科：有限状态机 SpringStateMachine文档：state-machine-concepts UML State Machine 实现一个状态机引擎，教你看清DSL的本质 ","date":"2024-08-16T10:21:36+08:00","image":"https://gloryjie.github.io/p/%E7%8A%B6%E6%80%81%E6%9C%BA%E7%AF%87%E4%B8%80%E6%A6%82%E5%BF%B5%E7%90%86%E8%A7%A3/cover_hubc0c84fe558bd0a18fe5845534db8b92_2319399_120x120_fill_box_smart1_3.png","permalink":"https://gloryjie.github.io/p/%E7%8A%B6%E6%80%81%E6%9C%BA%E7%AF%87%E4%B8%80%E6%A6%82%E5%BF%B5%E7%90%86%E8%A7%A3/","title":"状态机篇一：概念理解"},{"content":" 封面是《诛仙》动漫中的小白，白狐\nJTS，全称Java Topology Suite，是一个用于创建和操作向量几何的Java库。提供了对几何模型的抽象，以及各种空间操作和空间关系判断，非常强大。\n引入jar包 JTS有多个模块，这里只使用了核心的模块。\njts-core：提供几何模型的抽象、空间操作、空间关系判断算法等 jts-io-common：提供各种格式描述几何模型的输入输出包，如对WKT、WKB等格式 1 2 3 4 5 6 7 8 9 10 11 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.locationtech.jts\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jts-core\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.19.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.locationtech.jts.io\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jts-io-common\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.19.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 几何模型 JTS提供了常见的集合模型抽象，并且各具特点。\n模型 定义 常见应用 点（Point） 表示空间中的单个位置，由一对x,y坐标表示 表示兴趣点、事件位置等 多点（MultiPoint） 由多个独立的点组成的几何对象 表示多个相关但分散的位置，如连锁店分布，多个不同人位置 线（LineString） 由一系列点组成的一维几何对象，有起点和终点，中间可以有任意数量的点 表示道路、河流等线性特征 多线（MultiLineString） 由多个不相连的LineString组成的几何对象 表示复杂的道路网络、等高线等 多边形（Polygon） 由一系列首尾相连的线段围成的平面区域（可以有内部空洞） 表示行政区划、建筑物轮廓等 多多边形（MultiPolygon） 由多个独立的Polygon组成的几何对象，可以表示不相连的多个区域 表示群岛、复杂的行政区划 几何集合（GeometryCollection） 可以包含任意类型几何对象的集合，最灵活的几何类型，可以混合包含点、线、面等 表示复杂的空间场景，如包含多种类型要素的地图 JTS中的各几何模型对象如下，可以看到顶层的几何对象Geometry，所有实际的几何对象都继承该对象。 空间描述格式-WKB WKT（Well-Know Text）格式是一种文本格式，用于描述二维和三维几何对象的空间特征。 WKT的基本语法格式如下：\n1 几何模型类型 (模型数据) 示例如下所示\n1 2 3 点：POINT (282 455) 线：LINESTRING (260 250, 485 248, 520 380) 多边形：POLYGON ((320 390, 370 330, 470 360, 460 430, 375 432, 320 390)) JTS支持对该格式的读写操作，主要是两个对象WKTReader和WKTWriter，代码示例如下\n1 2 3 4 5 6 7 8 9 10 11 // 读取wkt描述的几何对象 WKTReader wktReader = new WKTReader(); Geometry point = wktReader.read(\u0026#34;POINT (282 455)\u0026#34;); Geometry line = wktReader.read(\u0026#34;LINESTRING (260 250, 485 248, 520 380)\u0026#34;); Geometry polygon = wktReader.read(\u0026#34;POLYGON ((320 390, 370 330, 470 360, 460 430, 375 432, 320 390))\u0026#34;); // 输出几何对象的wkt描述 WKTWriter wktWriter = new WKTWriter(); System.out.println(wktWriter.write(point)); System.out.println(wktWriter.write(line)); System.out.println(wktWriter.write(polygon)); 空间关系 JTS中的空间关系是基于DE-9IM（Dimensionally Extended Nine-Intersection Model）模型定义的，这里列举常见的空间关系\n空间关系 定义 相等 (Equals) 两个几何对象在拓扑上相等 相离 (Disjoint) 两个几何对象没有任何共同点 相交 (Intersects) 两个几何对象有至少一个共同点 内含 (Within) 几何对象A完全位于几何对象B内部 包含 (Contains) 几何对象A完全包含几何对象B 以该图形为例，两个多边形的关系判断的代码示例 1 2 3 4 5 6 7 8 9 WKTReader wktReader = new WKTReader(); Geometry geometryA = wktReader.read(\u0026#34;POLYGON ((320 390, 370 330, 470 360, 460 430, 375 432, 320 390))\u0026#34;); Geometry geometryB = wktReader.read(\u0026#34;POLYGON ((500 420, 430 360, 530 260, 500 420))\u0026#34;); System.out.println(\u0026#34;Equal: \u0026#34; + geometryA.equals(geometryB)); System.out.println(\u0026#34;Disjoint: \u0026#34; + geometryA.disjoint(geometryB)); System.out.println(\u0026#34;Intersects: \u0026#34; + geometryA.intersects(geometryB)); System.out.println(\u0026#34;Within: \u0026#34; + geometryA.within(geometryB)); System.out.println(\u0026#34;Contains: \u0026#34; + geometryA.contains(geometryB)); 空间操作 JTS提供了丰富的空间操作功能，用于处理和分析几何对象。这里列举常见的几种\n空间操作 定义 相交 (Intersection) 计算两个几何对象的共同部分 并集 (Union) 合并两个或多个几何对象 差集 (Difference) 从一个几何对象中减去另一个几何对象 以该图为例，操作示例代码如下 1 2 3 4 5 6 7 WKTReader wktReader = new WKTReader(); Geometry geometryA = wktReader.read(\u0026#34;POLYGON ((320 390, 370 330, 470 360, 460 430, 375 432, 320 390))\u0026#34;); Geometry geometryB = wktReader.read(\u0026#34;POLYGON ((500 420, 430 360, 530 260, 500 420))\u0026#34;); System.out.println(\u0026#34;Intersection: \u0026#34; + wktWriter.write(geometryA.intersection(geometryB))); System.out.println(\u0026#34;Union: \u0026#34; + wktWriter.write(geometryA.union(geometryB))); System.out.println(\u0026#34;Difference: \u0026#34; + wktWriter.write(geometryA.difference(geometryB))); 下面是Union合并后的效果 空间索引 最小外接矩形（MBR） 最小外接矩形MBR (Minimum Bounding Retangle)，是能够完全包含一个几何对象的最小矩形。 如下图所示，这个规则的矩形就是该多边形的MBR表示。 表示MBR非常简单，只需要知道他的左下角和右上角，那么就可以知道这个MBR图形了。如下图所示 知道了这个最小外接矩形有什么用？ 这里有个断言：如果点不在这个MBR内了，那么肯定不在这个多边形内。所以把点和MBR进行比较，就能够快速排除不可能有关系的多边形对象。\n那么如何快速的判断点是否在MBR中？比较坐标值的大小就可以了。示例代码如下\n1 2 3 4 mbr.getLngMin() \u0026lt;= point.getLng() \u0026amp;\u0026amp; mbr.getLngMax() \u0026gt;= point.getLng() \u0026amp;\u0026amp; mbr.getLatMin() \u0026lt;= point.getLat() \u0026amp;\u0026amp; mbr.getLatMax() \u0026gt;= point.getLat() 综上，MBR用简单的矩形来近似表示复杂的几何形状，将复杂的空间关系简化为矩形之间的关系。通过MBR这一层的初步筛选，就能够快速排除不可能有关系的多边形对象。\n在JTS中，Envelope对象来表示MBR。代码示例如下\n1 2 3 4 5 6 7 8 WKTReader wktReader = new WKTReader(); Geometry geometryA = wktReader.read(\u0026#34;POLYGON ((320 390, 370 330, 470 360, 460 430, 375 432, 320 390))\u0026#34;); Envelope envelope = geometryA.getEnvelopeInternal(); System.out.println(envelope.getMaxX()); System.out.println(envelope.getMaxY()); System.out.println(envelope.getMinX()); System.out.println(envelope.getMinY()); 空间索引 上述构建MBR可以理解为简单索引的一种，实际上有复杂的空间索引。常见空间索引有\nR树（R-tree）：平衡树，适用于多维空间数据（类似一维的B+树） 四叉树（Quad-tree）：将二维空间递归地分为四个象限 网格（Grid）：将空间划分为规则的网格单元 JTS提供了Quadtree（四叉树）、STRtree（基于R树的变体）的实现。构建R树空间索引的示例代码如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 WKTReader wktReader = new WKTReader(); Geometry geometryA = wktReader.read(\u0026#34;POLYGON ((320 390, 370 330, 470 360, 460 430, 375 432, 320 390))\u0026#34;); Geometry geometryB = wktReader.read(\u0026#34;POLYGON ((500 420, 430 360, 530 260, 500 420))\u0026#34;); STRtree rtree = new STRtree(); // 向R树种添加MBR，和自己的数据 rtree.insert(geometryA.getEnvelopeInternal(), \u0026#34;Polygon-A\u0026#34;); rtree.insert(geometryB.getEnvelopeInternal(), \u0026#34;Polygon-B\u0026#34;); rtree.build(); // 点只在Polygon-A中 System.out.println(rtree.query(wktReader.read(\u0026#34;POINT (337 391)\u0026#34;).getEnvelopeInternal())); // 点只在Polygon-B中 System.out.println(rtree.query(wktReader.read(\u0026#34;POINT (496 390)\u0026#34;).getEnvelopeInternal())); // 点在Polygon-A和Polygon-B的交集中 System.out.println(rtree.query(wktReader.read(\u0026#34;POINT (452 367)\u0026#34;).getEnvelopeInternal())); 总结 JTS还是很强大的，提供了几乎所有的空间计算上的东西。在实际应用过程中，需要加快一些计算过程，就需要使用上空间索引，一般都是在内存中构建索引树。在JTS之上，还有个基于JTS的GeoTools的工具，这个是更为强大。这一块由于只是处于应用层面，涉及的一些算法上的计算等就不过于深究，毕竟专业性较强。\n附录 参考 Java Topology Suite (JTS) GIS原理在线教程 ","date":"2024-07-17T20:25:28+08:00","image":"https://gloryjie.github.io/p/javatopologysuite%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/cover_hubaffd4205b0b02afbafe504f2ba8b6c7_2286570_120x120_fill_box_smart1_3.png","permalink":"https://gloryjie.github.io/p/javatopologysuite%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/","title":"JavaTopologySuite的简单使用"},{"content":" 封面为国漫《诛仙》中的女主 陆雪琪\nCopyOnWrite（缩写COW） 机制是一种并发编程的常用策略，用于处理数据集合在读写操作同时发生时的一致性问题。它的基本思想是每次修改操作（如添加或删除元素）都会创建集合的一个新副本，从而确保读操作始终在不变的集合视图上执行。\nCOW工作机制 读操作： 所有读操作（如 get()、size()）在当前不变的数组副本上进行，不需要加锁，因此性能非常高。 写操作： 写操作（如 add()、remove()）会复制当前数组，进行修改，并将修改后的新数组设置为底层数组。 写操作需要加锁以确保线程安全，但由于写操作是在新数组副本上进行的，因此不会阻塞读操作。 了解了COW机制后，就明白读操作是快而轻，写操作就很重。所以就会有以下的特点\n内存开销：由于每次写操作都会创建数组的副本，因此在写操作频繁的场景中会产生较高的内存开销和垃圾回收负担。 一致性：在 CopyOnWrite 集合中，迭代器返回的元素可能是过时的，因为迭代器遍历的是快照，不会反映最新的修改。 COW通常适用于读多写少的场景\n适用场景：CopyOnWrite 机制适用于读操作频繁而写操作较少的场景，例如缓存、白名单和黑名单等配置。 Java中的COW容器 Java中CopyOnWrite机制具体容器有两个\nCopyOnWriteArrayList CopyOnWriteArraySet：基于CopyOnWriteArrayList来实现的 所以主要看CopyOnWriteArrayList的实现。\n属性只有两个，底层就是一个数组，使用ReentrantLock来进行写数组的保护。\n1 2 3 4 5 /** The lock protecting all mutators */ final transient ReentrantLock lock = new ReentrantLock(); /** The array, accessed only via getArray/setArray. */ private transient volatile Object[] array; 下面是add方法的逻辑，实现比较简单。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 /** * Appends the specified element to the end of this list. * * @param e element to be appended to this list * @return {@code true} (as specified by {@link Collection#add}) */ public boolean add(E e) { final ReentrantLock lock = this.lock; // 写操作加锁保护 lock.lock(); try { // 获取数据快照 Object[] elements = getArray(); int len = elements.length; Object[] newElements = Arrays.copyOf(elements, len + 1); newElements[len] = e; setArray(newElements); return true; } finally { lock.unlock(); } } 再来看看get的逻辑。更简单了，和平时访问一个数据元素一样，不需要锁的保护。这里需要注意的就是先通过getArray获取了数据快照。\n1 2 3 4 5 6 7 8 9 10 11 12 /** * {@inheritDoc} * * @throws IndexOutOfBoundsException {@inheritDoc} */ public E get(int index) { return get(getArray(), index); } final Object[] getArray() { return array; } 对比Java8和21的实现变化 Java8和Java21中的实现变化不大，主要还是在使用锁的变化上。\nJava8：使用ReentrantLock Java21：使用synchronized关键字 这里贴一下Java21中的add代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 /** * The lock protecting all mutators. (We have a mild preference * for builtin monitors over ReentrantLock when either will do.) */ final transient Object lock = new Object(); /** * Appends the specified element to the end of this list. * * @param e element to be appended to this list * @return {@code true} (as specified by {@link Collection#add}) */ public boolean add(E e) { synchronized (lock) { Object[] es = getArray(); int len = es.length; es = Arrays.copyOf(es, len + 1); es[len] = e; setArray(es); return true; } } 可以看到lock属性发生了变化。属性上边的注释\nWe have a mild preference for builtin monitors over ReentrantLock when either will do.\n也就是作者更倾向于使用synchronized。但是在Java21中，使用synchronized会造成运行Virtual Thread的Carrier Thread被pinned住的问题。不知道后面会不会改回来使用ReentrantLock。\n附录 参考 ","date":"2024-06-13T20:12:48+08:00","image":"https://gloryjie.github.io/p/java-copyonwrite%E5%AE%B9%E5%99%A8/cover_hu0e51770fe8d4da95ee6ceb0cbcfd719c_1732175_120x120_fill_box_smart1_3.png","permalink":"https://gloryjie.github.io/p/java-copyonwrite%E5%AE%B9%E5%99%A8/","title":"Java CopyOnWrite容器"},{"content":" 封面是韩国的Arin，下面是抖音经常刷到的一个装扮\n这里直接使用SDKMAN进行jdk21的下载。（安利SDKMan这个工具，本地用来切换各版本sdk方便）\n1 sdk install java 22.0.1-oracle 正式发布的（非预览）新特性。并对语法层面的，也就是核心Java库相关的做个简单记录。\nJEP 分类 虚拟线程 核心 Java 库 有序集合 核心 Java 库 Record 模式 核心 Java 库 switch 模式匹配 核心 Java 库 分代 ZGC HotSpot 弃用 Windows 32 位 x86 端口 HotSpot 准备禁止动态加载代理 HotSpot 密钥封装机制 API 安全库 有序集合 JEP 431\n对于有序集合，，如List（ArrayList、LinkList等）、Deqeue、SortedSet等，没有一个共同的操作语义api区队双端就行操作。下面距离取第一个、最优一个元素的当前方式。\nCollection First element Last element List list.get(0) list.get(list.size() - 1) Deque deque.getFirst() deque.getLast() SortedSet sortedSet.first() sortedSet.last() LinkedHashSet linkedHashSet.iterator().next() // missing 实际开发中最常见的就是list.get(0)、list.get(list.size() - 1)。在上述背景下，新增了三个接口：SequencedCollection、SequencedSet、SequencedMap。下面来看下这三个接口的相关定义。\n下面是三个接口在集合框架体系中的关系。 SequencedCollection接口定义如下，都是对于首尾操作的方法，还有一个反转顺序的操作。 SequencedSet继承自SequenceCollection，重写了reversed方法的返回值而已。 SequencedMap是自己单独定义的，需要留意两个方法的返回值\nsequencedKeySet返回SequencedSet sequenedValues返回SequencdCollection 对于首尾操作就不需要自己去遍历或者指定index了，还加多了一个reverse操作。\nRecord模式 JEP440\n对于Record在日常使用者，个人还没有使用上（日常工作还在Java8），感触不是很深，先不研究。\nswitch支持数据类型匹配 直观感受就是支持了数据类型匹配，还支持null匹配👍。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 public class Main { public static void main(String[] args) { System.out.println(getTypeStr(1)); System.out.println(getTypeStr(\u0026#34;hello\u0026#34;)); System.out.println(getTypeStr(12.12d)); System.out.println(getTypeStr(123L)); System.out.println(getTypeStr(true)); } public static String getTypeStr(Object o) { return switch (o) { case null -\u0026gt; \u0026#34;null\u0026#34;; case Integer i -\u0026gt; String.format(\u0026#34;int %d\u0026#34;, i); case Long l -\u0026gt; String.format(\u0026#34;long %d\u0026#34;, l); case Double d -\u0026gt; String.format(\u0026#34;double %f\u0026#34;, d); case String s -\u0026gt; String.format(\u0026#34;String %s\u0026#34;, s); case Boolean b -\u0026gt; String.format(\u0026#34;Boolean %b\u0026#34;, b); default -\u0026gt; o.toString(); }; } } VirtualThread虚拟线程 JEP444\n什么事虚拟线程？看下VirtualThread类上的注释。（一句话就明白了）\nA thread that is scheduled by the Java virtual machine rather than the operating system.\n对于开发者来说虚拟线程在使用体验上和 Thread 几乎没有区别，与之前的 API 互相兼容，但是相比之下虚拟线程资源占用非常少。下面来对比一下使用。\nThread类的使用方式\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // 原始线程的使用 Thread thread = new Thread(() -\u0026gt; { System.out.println(\u0026#34;hello thread\u0026#34;); }, \u0026#34;SystemThread\u0026#34;); thread.start(); // 虚拟线程 Thread virtualThread = Thread.ofVirtual().name(\u0026#34;VirtualThread\u0026#34;).unstarted(() -\u0026gt; { System.out.println(\u0026#34;hello virtual thread\u0026#34;); }); virtualThread.start(); Thread.startVirtualThread(() -\u0026gt; { System.out.println(\u0026#34;hello virtual thread, startVirtualThread\u0026#34;); }); ExecutorService线程池使用方式\n1 2 3 4 5 6 7 8 9 10 11 // 创建并提交执行虚拟线程 long start = System.currentTimeMillis(); try (var executor = Executors.newVirtualThreadPerTaskExecutor()) { IntStream.range(0, 10_000).forEach(i -\u0026gt; { executor.submit(() -\u0026gt; { Thread.sleep(Duration.ofSeconds(1)); return i; }); }); } System.out.println(\u0026#34;time:\u0026#34; + (System.currentTimeMillis() - start) + \u0026#34;ms\u0026#34;); VirtualThread是不需要池化的，用的时候新建即可。后续会对这一块进一步研究学习。 附录 参考 Java 21 新功能介绍 (LTS) 咖啡屋视频：通向Java21-02-Java虚拟线程 咖啡屋视频：通向Java21-04-新的API 咖啡屋视频：通向Java21-07-完整的模式匹配【最终回】 ","date":"2024-04-21T11:33:39+08:00","image":"https://gloryjie.github.io/p/java21%E8%AF%AD%E6%B3%95%E7%89%B9%E6%80%A7/cover_hua0dda0fd1975efc7e10ecc9bbca3e0a7_198222_120x120_fill_q75_box_smart1.jpeg","permalink":"https://gloryjie.github.io/p/java21%E8%AF%AD%E6%B3%95%E7%89%B9%E6%80%A7/","title":"Java21语法特性"},{"content":" 封面是《斗罗大陆2绝世唐门》中的凌落宸，用冰技能, 图片由AI生成，完成图片放在附录中\n课程首页以及实验说明相关介绍链接在附录中。\n课程理解 简单的说，就是用Go来实现一个单机多进程版本的MapReduce。(MapReduce计算模型可以去搜索相关文章了解)。会有如下两种类型的进程\nCoordinator协调者：作为一个协调着，协调Map、Reduce的任务交给不同的Worker去执行，协调Map、Reduce阶段（执行完所有Map任务之后才可以去执行Reduce任务） Worker执行器：任务执行者，执行Map、Reduce任务 起来一个MR任务后，只会有一个Coordinator进程，可以有多个Worker进程。需要去考虑和解决下面的几个问题\nCoordinator如何感知worker？ 所有Map任务执行完成后，方可进行Reduce任务，Coordinator如何进行协调分配任务？ Map任务会产生临时文件作为输出，需要收集所有的临时文件内容作为Reduce的输入，两种任务之间如何配合？ Worker可能会crash，正在处理的任务该如何处理？ Worker执行任务时间可能过长，如何处理？ 课程前置知识 1、MapReduce的运行机制\n2、Go内置的RPC通信\n3、Go的锁保护机制\n4、Go本地的定时任务time.Ticker 任务运行机制 Coordinator的执行入口在mrcoordinator.go文件中，逻辑就是创建一个Coordinator结构体实例，之后循环执行Done()方法，来判断Coordinator是否已经结束，进而判断整个MR任务是否结束。\nWorker的执行入口在mrworker.go文件中，逻辑就是加载Map、Reduce的函数，之后调用worker的Worker方法。当前Worker进程具体该如何执行Map、Reduce任务，需要自己在Worker方法内区实现。\n实验只需要修改src/mr里边的三个文件，在里边书写自己的逻辑代码\ncoordinator.go worker.go rpc.go 实现设计 这里先明确一下概念，对启动一个MR任务称之为Job，而Map任务、Reduce任务称为Task。后面都用英文来表示。 Coordinator的设计 一个Coordinator需要知道MR Job当前需要处理的files，并且有需要几个Reduce（执行MakeCoordinator�的时候会传入）。\n由于一个job会存在map、Reduce阶段，这里给job设计了几个阶段（状态），用整型来表示。如下\n阶段 阶段值 初始阶段 1 Map阶段 2 Reduce阶段 3 等待Worker下线阶段 4 job结束 5 Coordinator需要知道当前有哪些Worker存在，判断其Worker的存活，进而判断任务是否还在继续执行。所以需要用一个结构体来表是worker节点，判断存活的依据简单的心跳处理。\nCoordinator需要推进map、reduce任务的执行，需要维护task列表。（具体task的设计看下面）这里分别为两种类型的task设立两个列表，使用map存放。\n因为执行完map任务后，才可以执行reduce任务，这里简单起见，判断各个阶段任务完成的标记使用计数来表示。所以而外需要两个统计数值：map任务完成数量、reduce任务完成数量。\n多个Worker请求，需要并发修改task结构体的状态以及统计任务数等，会需要互斥访问，还需要一个mutex进行数据保护。\n总结上述，一个Coordinator内包含的结构如下。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 type Coordinator struct { // Your definitions here. files []string reduceNum int jobStage int workerNodeMap map[int]*workerNode mapTaskMap map[int]*TaskResult reduceTaskMap map[int]*TaskResult mapTaskDoneCount int reduceTaskDoneCount int taskMutex sync.Mutex } type workerNode struct { workerId int lastHeartBeatTime int64 } const JOB_STAGE_INIT = 1 const JOB_MAP_STAGE = 2 const JOB_REDUCE_STAGE = 3 const JOB_END = 5 const MAP_TASK = \u0026#34;map\u0026#34; const REDUCE_TASK = \u0026#34;reduce\u0026#34; Task的设计 mapTask、reduceTask都有很大的相似性，外出来看都是输入、输出。所以这里设计都使用同一个结构体来表示两种阶段的任务。使用一个type字段进行区分即可。这里也给task进行了状态的划分。（这里假设task没有失败的可能）。\n阶段 阶段值 待执行 1 执行中 2 执行完成 3 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 const TASK_PENDING = 1 const TASK_EXECUTING = 2 const TASK_COMPLETED = 3 type TaskResult struct { TaskId int // 由Coordinator进行分配 TaskType string // map or reduce Status int FilePath []string // input file path ResultPath []string // output file path ExecuteSuccess bool // execute result WorkerId int // execute worker NReduce int StartExecuteTime int64 } type HeartbeatResult struct { WorkerId int Shutdown bool // 当true时直接退出进程 } Worker的设计 worker比较简单，主要是和Coordinator进行通信，执行map、reduce任务。\n由于map、reduce类型的task都是worker执行，中间文件的处理也落到了worker身上。下面是处理各个阶段的逻辑\nmap阶段：worker会根据reduce的数量n，创建n个临时文件，并将map产生的kv结果，分散写入到这n个临时文件中。之后，将这n个临时文件路径作为当前map任务的ResultPath，上报给Coordinator。 Coordinator协调阶段：将map产出的临时文件，写入到对应的Reduce任务的FilePath中作为输入 reduce阶段：worker读取所有FilePath中的文件后，做一个sort、merge，执行Reduce函数。将产出写入到mr-out-taskId的文件中（这里简单起见，不写入tmp file了） 这里和实验推荐的一样，将map生成的中间KV数据作为json结构写入到临时文件中。 RPC通信设计 Coordinator和worker之间，是采用不断请求的模式（pull）。Coordinator不会主动给worker发送数据。\n这里设计了三种的接口交互\nworker定时上报心跳给Coordinator worker不断地从Coordinator中获取任务执行 worker执行完一个任务后，上报执行结果给Coordinator 基本如下图所示：\n较重要的定时任务 定时任务主要是解决Worker获取到任务后，但是Worker宕机的情况，这时候Worker执行的task需要交给其他Worker去执行。\n设计上，通过判定Worker的心跳超时时间来判定Worker是否宕机，以及按照实验首页说的，简单的判断如果task执行时间超过了10s，也认为该任务需要切换Worker执行。\n下面是Coordinator的两个定时任务逻辑\n扫描Worker列表，如果上一次心跳时间超过了预定的超时时间，那么就从Worker列表中剔除 扫描task列表，任务处于正在执行中，如果其执行的Worker并不在Worker的列表中，或者执行时间超过了10s，则重置该任务为待执行状态 这样就可以重置Task的状态，存活的Worker就可以获取得到Task执行。\nCoordinator执行阶段推进 在执行完所有的Map任务之后，才可以执行Reduce任务。设计上，将任务推进放到了Coordinator中接受任务执行结果的逻辑中。如果所有的Map任务执行完成了，那么就将JOB_STAGE修改成Reduce阶段，这样Worker就可以获取到Reduce任务去执行。\n只有Coordinator知道整体的完成情况，但是Worker不知道。Worker可以简单的设计为如果RPC调用失败，就认为Coordinator结束了，自己也跟着退出。或者有某种RPC结果能让Worker知道当前需要退出。\n这里设计通过Worker的心跳返回结果来告知Worker下一步的执行，如果收到shutdown命令，那么就直接退出。Coordinator在Reduce阶段结束，就直接走到end阶段。\n踩坑 对于go语言不太熟练，一些常见的坑踩了不少\n切片slice、哈希表map的遍历修改、删除元素 go内置rpc使用，对于默认值是如何处理的（这里对于各种状态，建议避开默认值） 这里有个坑调试了很久，就是worker在去请求任务的时候，创建的TaskResult结构体是放在了for循环外边，导致在导致每次调用获取到的结果会掺杂了上次调用的结果😭，还有默认值不修改的问题。\n下面放点代码示例\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 func getTaskFromCoordinator(workerId int) TaskResult { // 问题就在这里，只创建了一次，内部for循环会共用一个实例，多次请求和掺杂上一次请求的结果 // result := \u0026amp;TaskResult{} for { // 正确应该放在循环里边 result := \u0026amp;TaskResult{} ok := call(\u0026#34;Coordinator.GetTaskToExecute\u0026#34;, \u0026amp;workerId, result) if ok { if result.TaskId \u0026gt; -1 { return *result } time.Sleep(time.Second * 2) } else { log.Fatal(\u0026#34;获取任务失败\u0026#34;) } } } 导致的结果就是如下，明明Coordinator返回的taskId是0，为啥worker收到的taskId是-1？？？\n原因就是上一次请求的结果返回的就是-1，这一次返回的是0，是个默认值，go的rpc是不会传输，也就是不会去修改-1，真是日了狗。所以这里建议对于各种状态、id值的定义不要使用默认值！！！\n总结 这里是假设所有的Task最终在10s内都是会执行完成的，10s未完成则交给别的Worker去执行。实际上，Task的执行是会出现各种各样的情况的。而且，这里设计上每一个输入的file作为一个Map任务，会出现计算倾斜的情况。理想情况下需要平均的进行切分数据，让每个Map任务尽可能的处理相同大小的数据。\n首次接触go语言来写项目，不会的就边搜索别写，效率偏慢些，debug半天。不过主要是要在关键节点输出详细的日志信息，便于观察各种数据结构的具体变更情况。\n附录 课程首页：https://pdos.csail.mit.edu/6.824/index.html\n课程实验说明：https://pdos.csail.mit.edu/6.824/labs/lab-mr.html\n参考 ","date":"2024-03-24T21:37:07+08:00","image":"https://gloryjie.github.io/p/mit6824_lab1/cover_hu4faae92f089e584f7c8e1fb189bc7c34_1938005_120x120_fill_box_smart1_3.png","permalink":"https://gloryjie.github.io/p/mit6824_lab1/","title":"MIT6824实验1-MapReduce设计"},{"content":" 封面壁纸为国漫《仙逆》的女主 李慕婉\n射线法简介 射线法的基本思想是重目标点向一个方向引出一条无限的射线法，统计射线与多边形的边相交的数量\n如果是偶数，则点在多边形外 如果是奇数，则点在多边形内 一般射线的方向是x轴的正数方向。算法的时间复杂度为O(n)，n为多边形的边（点）数。\n情况列举和分享 下面几种情况都算是点在多边形内\n点在多边形内 点和多边形的顶点重叠 点在多边形的边上 射线法将判断在多边形内，转移为判断点和边的关系。所以算法的主要逻辑，就是在判断点射线和边的空间关系。有两种情况需要特殊处理。\n射线经过边的顶点 判断点在斜线的左侧的三角函数 从点引出的射线和多边形的边有下面几种情况需要考虑\n点在在边的上方、下方、右侧，不会相交 边水平的情况，不判断交点数，只判断是否在线上 射线经过边的顶点，则需要使用权重值来解决经过顶点的问题（涵盖了边垂直的情况） B点在A点的下方，那么权重值-0.5 B点在A点的上方，那么权重值+0.5 边垂直的情况 点在垂直的边P上，则点在多边形内 点在在垂直的边的左边，则点与该边必然有交点 边斜线的情况 点在线的左边，肯定会有交点 通过三角函数来判断点是否在边的左边 各种情况的判断代码 点的表达\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 @Data @AllArgsConstructor @NoArgsConstructor public class Point { /** * 经度 */ private Double lng; /** * 纬度 */ private Double lat; } 目标点和多边形的顶点重合\n1 2 3 4 5 6 // 顶点重合的情况 for (Point polygonPoint : polygonPoints) { if (Objects.equals(target, polygonPoint)) { return true; } } 点在的上方、下方、右侧，射线肯定不会和边相交\n1 2 3 4 if (target.getLat() \u0026lt; minLat || target.getLat() \u0026gt; maxLat || target.getLng() \u0026gt; maxLng) { pointA = pointB; continue; } 边水平的情况,若点在水平的边上，则点在多边形内。平行重叠的情况，不做交点数判断。\n1 2 3 4 5 6 7 if (Objects.equals(pointA.getLat(), pointB.getLat())) { if (target.getLng() \u0026lt;= maxLng \u0026amp;\u0026amp; target.getLng() \u0026gt;= minLng) { return true; } pointA = pointB; continue; } 射线经过边的顶点(此时边可能垂直)，解决方案为：如果交点是待测多边形某个边上的一个顶点，则只有当该边的另一个顶点位于射线下方时，交点才算在内。这实际上等同于将与射线相交的顶点视为略高于射线。\n1 2 3 4 5 6 7 8 9 10 11 12 if ((Objects.equals(target.getLat(), pointA.getLat()) \u0026amp;\u0026amp; target.getLng() \u0026lt; pointA.getLng()) || Objects.equals(target.getLat(), pointB.getLat()) \u0026amp;\u0026amp; target.getLng() \u0026lt; pointB.getLng()) { if (pointB.getLat() \u0026lt; pointA.getLat()) { // B点在A点的下方，那么权重值-0.5 intersectPointWeights -= 0.5; } else if (pointB.getLat() \u0026gt; pointA.getLat()) { // B点在A点的上方，那么权重值+0.5 intersectPointWeights += 0.5; } pointA = pointB; continue; } 边垂直的情况\n1 2 3 4 5 6 7 8 9 10 11 12 if (Objects.equals(pointA.getLng(), pointB.getLng())) { if (Objects.equals(target.getLng(), pointA.getLng())) { // 若点在垂直的边P上，则点在多边形内 return true; } else if (target.getLng() \u0026lt; pointA.getLng()) { // 若点在在垂直的边的左边，则点与该边必然有交点 intersectPointCount++; } pointA = pointB; continue; } 边斜线的情况，使用三角函数来判断\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 if (target.getLng() \u0026lt;= minLng) { // 点point的x坐标在边的左侧，那么肯定相交 intersectPointCount++; } else if (target.getLng() \u0026lt; maxLng) { // 点point的x坐标在点B、A的x坐标中间 double diff = (target.getLat() - pointA.getLat()) * (pointA.getLng() - pointB.getLng()) / (pointA.getLat() - pointB.getLat()) + pointA.getLng() - target.getLng(); if (diff \u0026gt;= 0) { if (diff \u0026lt; PRECISION) { // 由于double精度在计算时会有损失，故匹配一定的容差 // 点在斜线P1P2上 return true; } else { // 点向右射线与斜线P1P2有交点 intersectPointCount++; } } } 测试示例 图形如下\n点集合，也就是多边形\n1 [{\u0026#34;lng\u0026#34;:110.269889,\u0026#34;lat\u0026#34;:21.308982},{\u0026#34;lng\u0026#34;:110.277883,\u0026#34;lat\u0026#34;:21.231378},{\u0026#34;lng\u0026#34;:110.275219,\u0026#34;lat\u0026#34;:21.178585},{\u0026#34;lng\u0026#34;:110.309195,\u0026#34;lat\u0026#34;:21.166692},{\u0026#34;lng\u0026#34;:110.345361,\u0026#34;lat\u0026#34;:21.166692},{\u0026#34;lng\u0026#34;:110.345361,\u0026#34;lat\u0026#34;:21.225846},{\u0026#34;lng\u0026#34;:110.37871,\u0026#34;lat\u0026#34;:21.218632},{\u0026#34;lng\u0026#34;:110.416809,\u0026#34;lat\u0026#34;:21.210863},{\u0026#34;lng\u0026#34;:110.41919,\u0026#34;lat\u0026#34;:21.224181},{\u0026#34;lng\u0026#34;:110.419648,\u0026#34;lat\u0026#34;:21.234822},{\u0026#34;lng\u0026#34;:110.385148,\u0026#34;lat\u0026#34;:21.282747},{\u0026#34;lng\u0026#34;:110.351299,\u0026#34;lat\u0026#34;:21.286387},{\u0026#34;lng\u0026#34;:110.269889,\u0026#34;lat\u0026#34;:21.308982}] 测试代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 System.out.println(\u0026#34;图形外，射线和线水平，不在线上：\u0026#34; + RayCastUtil.isPointInPolygon(new Point(110.301195,21.166692), polygonPointList)); System.out.println(\u0026#34;图形内, 射线和线水平，在线上：\u0026#34; + RayCastUtil.isPointInPolygon(new Point(110.319195,21.166692), polygonPointList)); System.out.println(\u0026#34;图形内，射线和线垂直：\u0026#34; + RayCastUtil.isPointInPolygon(new Point(110.319195,21.186692), polygonPointList)); System.out.println(\u0026#34;图形外，射线和线垂直：\u0026#34; + RayCastUtil.isPointInPolygon(new Point(110.219195,21.186692), polygonPointList)); System.out.println(\u0026#34;图形内，经过线顶点：\u0026#34; + RayCastUtil.isPointInPolygon(new Point(110.305361,21.225846), polygonPointList)); System.out.println(\u0026#34;图形外，经过线顶点：\u0026#34; + RayCastUtil.isPointInPolygon(new Point(110.245361,21.225846), polygonPointList)); System.out.println(\u0026#34;图形内，和一条斜线相交：\u0026#34; + RayCastUtil.isPointInPolygon(new Point(110.305361,21.265846), polygonPointList)); System.out.println(\u0026#34;图形外，和一条斜线相交：\u0026#34; + RayCastUtil.isPointInPolygon(new Point(110.245361,21.265846), polygonPointList)); System.out.println(\u0026#34;图形内，和多条线相交：\u0026#34; + RayCastUtil.isPointInPolygon(new Point(110.305361,21.221846), polygonPointList)); System.out.println(\u0026#34;图形外，和多条线相交：\u0026#34; + RayCastUtil.isPointInPolygon(new Point(110.245361,21.221846), polygonPointList)); 完整代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 public class RayCastUtil { private static final double PRECISION = 2e-10; public static boolean isPointInPolygon(Point target, List\u0026lt;Point\u0026gt; polygonPoints) { // 这里不需要首尾相连，有些不需要，这就 if (Objects.equals(polygonPoints.get(0), polygonPoints.get(polygonPoints.size() - 1))) { polygonPoints = polygonPoints.subList(0, polygonPoints.size() - 1); } // 顶点重合的情况 for (Point polygonPoint : polygonPoints) { if (Objects.equals(target, polygonPoint)) { return true; } } // X轴射线与多边形的交点数 int intersectPointCount = 0; // X轴射线与多边形顶点相交的权值 double intersectPointWeights = 0; // pointA -\u0026gt; pointB 代表一条边 Point pointA = polygonPoints.get(0); Point pointB = null; final int pointSize = polygonPoints.size(); for (int i = 1; i \u0026lt;= pointSize; i++) { // for中定义\u0026lt;=以及这里的%取余，是为了关注最后一个节点连接首节点这条边的情况 pointB = polygonPoints.get(i % pointSize); double minLat = Math.min(pointA.getLat(), pointB.getLat()); double maxLat = Math.max(pointA.getLat(), pointB.getLat()); double minLng = Math.min(pointA.getLng(), pointB.getLng()); double maxLng = Math.max(pointA.getLng(), pointB.getLng()); // 目标点在的上方、下方、右侧，那么就不会相交 if (target.getLat() \u0026lt; minLat || target.getLat() \u0026gt; maxLat || target.getLng() \u0026gt; maxLng) { pointA = pointB; continue; } // 边水平的情况,若点在水平的边上，则点在多边形内, if (Objects.equals(pointA.getLat(), pointB.getLat())) { if (target.getLng() \u0026lt;= maxLng \u0026amp;\u0026amp; target.getLng() \u0026gt;= minLng) { return true; } pointA = pointB; continue; } // 边界处理：射线经过边的顶点(此时边可能垂直) if ((Objects.equals(target.getLat(), pointA.getLat()) \u0026amp;\u0026amp; target.getLng() \u0026lt; pointA.getLng()) || Objects.equals(target.getLat(), pointB.getLat()) \u0026amp;\u0026amp; target.getLng() \u0026lt; pointB.getLng()) { if (pointB.getLat() \u0026lt; pointA.getLat()) { // B点在A点的下方，那么权重值-0.5 intersectPointWeights -= 0.5; } else if (pointB.getLat() \u0026gt; pointA.getLat()) { // B点在A点的上方，那么权重值+0.5 intersectPointWeights += 0.5; } pointA = pointB; continue; } // 边垂直的情况 if (Objects.equals(pointA.getLng(), pointB.getLng())) { if (Objects.equals(target.getLng(), pointA.getLng())) { // 若点在垂直的边P上，则点在多边形内 return true; } else if (target.getLng() \u0026lt; pointA.getLng()) { // 若点在在垂直的边的左边，则点与该边必然有交点 intersectPointCount++; } pointA = pointB; continue; } // 边斜的情况 if (target.getLng() \u0026lt;= minLng) { // 点point的x坐标在边的左侧，那么肯定相交 intersectPointCount++; } else if (target.getLng() \u0026lt; maxLng) { // 点point的x坐标在点B、A的x坐标中间 double diff = (target.getLat() - pointA.getLat()) * (pointA.getLng() - pointB.getLng()) / (pointA.getLat() - pointB.getLat()) + pointA.getLng() - target.getLng(); if (diff \u0026gt;= 0) { if (diff \u0026lt; PRECISION) { // 由于double精度在计算时会有损失，故匹配一定的容差 // 点在斜线P1P2上 return true; } else { // 点向右射线与斜线P1P2有交点 intersectPointCount++; } } } pointA = pointB; } return (intersectPointCount + Math.abs(intersectPointWeights)) % 2 != 0; } } 附录 参考 YouTube视频：Checking if a point is inside a polygon is RIDICULOUSLY simple (Ray casting algorithm) - Inside code\n判断点是否在多边形内的Python实现及小应用（射线法）\n维基百科：多边形内的点\n","date":"2024-03-04T20:33:08+08:00","image":"https://gloryjie.github.io/p/%E5%B0%84%E7%BA%BF%E6%B3%95-%E5%88%A4%E6%96%AD%E7%82%B9%E6%98%AF%E5%90%A6%E5%9C%A8%E5%A4%9A%E8%BE%B9%E5%BD%A2%E5%86%85/cover_hue2c682d0e4643ecbc5c998a202920083_1132640_120x120_fill_q75_box_smart1.jpeg","permalink":"https://gloryjie.github.io/p/%E5%B0%84%E7%BA%BF%E6%B3%95-%E5%88%A4%E6%96%AD%E7%82%B9%E6%98%AF%E5%90%A6%E5%9C%A8%E5%A4%9A%E8%BE%B9%E5%BD%A2%E5%86%85/","title":"射线法 判断点是否在多边形内"},{"content":" 1 封面是《死亡搁浅》游戏中的 玛玛 官方有教程：https://resilience4j.readme.io/v1.7.0/docs/getting-started-3\n这里做个简单使用记录。 版本要求 Resilience4j版本 JDK版本 1.7 8 2.0 17 这里用的jdk8，使用Resilience4j的1.7版本。mvn依赖如下\n1 2 3 4 5 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;io.github.resilience4j\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;resilience4j-spring-boot2\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.7.1\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 这个包把Resilience4j的基本组件都引入进来了。\nyml配置 配置可以有三个层级的配置，分别可以继承。\n修改默认配置 自定义可共享的配置 实例自定义配置 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 resilience4j.circuitbreaker: # 指定对应的组件 configs: default: # 修改默认配置 slidingWindowSize: 100 permittedNumberOfCallsInHalfOpenState: 10 waitDurationInOpenState: 10000 failureRateThreshold: 60 eventConsumerBufferSize: 10 registerHealthIndicator: true someShared: # 可共享的配置 slidingWindowSize: 50 permittedNumberOfCallsInHalfOpenState: 10 instances: # 下面是实例自定义配置 backendA: # 实例名称 baseConfig: default # 指定继承的配置 waitDurationInOpenState: 5000 backendB: baseConfig: someShared 事件监听器 Resilience4j提供了两种细粒度的时间监听\nRegistry组件的增、删、替换事件 组件实例的状态变化事件 Resilience4j原生使用时在对应组件实例的基础上去进行设置监听，但是结合SpringBoot之后是没有办法直接拿到对应的组件实例。可以通过监听实例的增、删、替换的动作，进而拿到对应的实例，之后再进行监听实例状态的变更。\n自己创建的RegistryEventConsumer的Bean，会自动添加到SpringBoot自身管理的CircuitBreakerRegistry中。\n以监听CircuitBreaker组件为例，参考代码如下（IMessageService为自己的bean）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 @Bean public RegistryEventConsumer\u0026lt;CircuitBreaker\u0026gt; circuitBreakerEventConsumer(IMessageService messageService){ return new RegistryEventConsumer\u0026lt;CircuitBreaker\u0026gt;() { @Override public void onEntryAddedEvent(EntryAddedEvent\u0026lt;CircuitBreaker\u0026gt; entryAddedEvent) { entryAddedEvent.getAddedEntry().getEventPublisher().onStateTransition(event -\u0026gt; { String circuitBreakerName = event.getCircuitBreakerName(); CircuitBreaker.State fromState = event.getStateTransition().getFromState(); CircuitBreaker.State toState = event.getStateTransition().getToState(); log.info(\u0026#34;CircuitBreaker \u0026#39;{}\u0026#39; changed state from {} to {}\u0026#34;, circuitBreakerName, fromState, toState); StringBuilder builder = new StringBuilder(); builder.append(\u0026#34;\u0026lt;font color=\\\u0026#34;warning\\\u0026#34;\u0026gt;断路器状态发生变化 \u0026#34;).append(DateUtil.now()).append(\u0026#34; \u0026lt;/font\u0026gt;\\n\u0026#34;); builder.append(\u0026#34;\u0026gt; 断路器名称：\u0026#34;).append(circuitBreakerName).append(\u0026#34;\\n\u0026#34;); builder.append(\u0026#34;\u0026gt; 变化前状态：\u0026#34;).append(fromState).append(\u0026#34;\\n\u0026#34;); builder.append(\u0026#34;\u0026gt; 变化后状态：\u0026#34;).append(toState).append(\u0026#34;\\n\u0026#34;); builder.append(\u0026#34;请尽快处理！！！\u0026#34;); messageService.reportDefaultMsg(builder.toString()); }); } @Override public void onEntryRemovedEvent(EntryRemovedEvent\u0026lt;CircuitBreaker\u0026gt; entryRemoveEvent) { } @Override public void onEntryReplacedEvent(EntryReplacedEvent\u0026lt;CircuitBreaker\u0026gt; entryReplacedEvent) { } }; } 使用形式 注解使用 只需要在对应的方法加上对应组件的直接即可。还可以在添加降级处理的方，会自动根据异常类型进行批量。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 @CircuitBreaker(name = BACKEND, fallbackMethod = \u0026#34;fallback\u0026#34;) @RateLimiter(name = BACKEND) @Bulkhead(name = BACKEND, fallbackMethod = \u0026#34;fallback\u0026#34;) @Retry(name = BACKEND) @TimeLimiter(name = BACKEND) public Mono\u0026lt;String\u0026gt; method(String param1) { return Mono.error(new NumberFormatException()); } private Mono\u0026lt;String\u0026gt; fallback(String param1, CallNotPermittedException e) { return Mono.just(\u0026#34;Handled the exception when the CircuitBreaker is open\u0026#34;); } private Mono\u0026lt;String\u0026gt; fallback(String param1, BulkheadFullException e) { return Mono.just(\u0026#34;Handled the exception when the Bulkhead is full\u0026#34;); } private Mono\u0026lt;String\u0026gt; fallback(String param1, NumberFormatException e) { return Mono.just(\u0026#34;Handled the NumberFormatException\u0026#34;); } // 其实也可以写一个通用的，内部if else好了，减少方法的数量 private Mono\u0026lt;String\u0026gt; fallback(String param1, Exception e) { return Mono.just(\u0026#34;Handled any other exception\u0026#34;); } 代码使用 注解都是基于AOP去处理的，通病就是调用内部方法的时候是不会生效的。可以手动获取到对应的实力。\n1 2 3 4 5 @Resource private CircuitBreakerRegistry circuitBreakerRegistry; // 从registry获取实例，和注解使用的是同一个实例 circuitBreakerRegistry.circuitBreaker(\u0026#34;tencentAddressService\u0026#34;); starter的配置过程 结合SpringBoot的starter，流程基本就是读取配置，创建各种Bean组件。提供了各种注解，则过程就是基于Aop去实现的。这里简单看下CircuitBreaker的实现过程。\n基本涉及两个类\nCircuitBreakerConfiguration配置类，负责启动时创建断路器相关的Bean CircuitBreakerAspect切面处理，CircuitBreaker注解的处理 Bean的生成 两个关键的Bean\nCircuitBreakerRegistry CircuitBreakerAspect 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 @Bean @Primary public RegistryEventConsumer\u0026lt;CircuitBreaker\u0026gt; circuitBreakerRegistryEventConsumer( Optional\u0026lt;List\u0026lt;RegistryEventConsumer\u0026lt;CircuitBreaker\u0026gt;\u0026gt;\u0026gt; optionalRegistryEventConsumers) { // 自定义的RegistryEventConsumer会注入进来 return new CompositeRegistryEventConsumer\u0026lt;\u0026gt;( optionalRegistryEventConsumers.orElseGet(ArrayList::new)); } @Bean public CircuitBreakerRegistry circuitBreakerRegistry( EventConsumerRegistry\u0026lt;CircuitBreakerEvent\u0026gt; eventConsumerRegistry, RegistryEventConsumer\u0026lt;CircuitBreaker\u0026gt; circuitBreakerRegistryEventConsumer, @Qualifier(\u0026#34;compositeCircuitBreakerCustomizer\u0026#34;) CompositeCustomizer\u0026lt;CircuitBreakerConfigCustomizer\u0026gt; compositeCircuitBreakerCustomizer) { CircuitBreakerRegistry circuitBreakerRegistry = createCircuitBreakerRegistry( circuitBreakerProperties, circuitBreakerRegistryEventConsumer, compositeCircuitBreakerCustomizer); registerEventConsumer(circuitBreakerRegistry, eventConsumerRegistry); // then pass the map here initCircuitBreakerRegistry(circuitBreakerRegistry, compositeCircuitBreakerCustomizer); return circuitBreakerRegistry; } @Bean @Conditional(value = {AspectJOnClasspathCondition.class}) public CircuitBreakerAspect circuitBreakerAspect( CircuitBreakerRegistry circuitBreakerRegistry, @Autowired(required = false) List\u0026lt;CircuitBreakerAspectExt\u0026gt; circuitBreakerAspectExtList, FallbackDecorators fallbackDecorators, SpelResolver spelResolver ) { return new CircuitBreakerAspect(circuitBreakerProperties, circuitBreakerRegistry, circuitBreakerAspectExtList, fallbackDecorators, spelResolver); } 切面处理逻辑 切面的逻辑比较简单\n看看有没有注解 circuitBreakerRegistry中获取CircuitBreaker实例 是否使用fallback，不同的处理 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 @Pointcut(value = \u0026#34;@within(circuitBreaker) || @annotation(circuitBreaker)\u0026#34;, argNames = \u0026#34;circuitBreaker\u0026#34;) public void matchAnnotatedClassOrMethod(CircuitBreaker circuitBreaker) { } @Around(value = \u0026#34;matchAnnotatedClassOrMethod(circuitBreakerAnnotation)\u0026#34;, argNames = \u0026#34;proceedingJoinPoint, circuitBreakerAnnotation\u0026#34;) public Object circuitBreakerAroundAdvice(ProceedingJoinPoint proceedingJoinPoint, @Nullable CircuitBreaker circuitBreakerAnnotation) throws Throwable { // 方法上有没有注解 Method method = ((MethodSignature) proceedingJoinPoint.getSignature()).getMethod(); String methodName = method.getDeclaringClass().getName() + \u0026#34;#\u0026#34; + method.getName(); if (circuitBreakerAnnotation == null) { circuitBreakerAnnotation = getCircuitBreakerAnnotation(proceedingJoinPoint); } if (circuitBreakerAnnotation == null) { //because annotations wasn\u0026#39;t found return proceedingJoinPoint.proceed(); } // spel相关的 String backend = spelResolver.resolve(method, proceedingJoinPoint.getArgs(), circuitBreakerAnnotation.name()); io.github.resilience4j.circuitbreaker.CircuitBreaker circuitBreaker = getOrCreateCircuitBreaker( methodName, backend); Class\u0026lt;?\u0026gt; returnType = method.getReturnType(); String fallbackMethodValue = spelResolver.resolve(method, proceedingJoinPoint.getArgs(), circuitBreakerAnnotation.fallbackMethod()); // 没有fallback if (StringUtils.isEmpty(fallbackMethodValue)) { return proceed(proceedingJoinPoint, methodName, circuitBreaker, returnType); } // 有fallback FallbackMethod fallbackMethod = FallbackMethod .create(fallbackMethodValue, method, proceedingJoinPoint.getArgs(), proceedingJoinPoint.getTarget()); return fallbackDecorators.decorate(fallbackMethod, () -\u0026gt; proceed(proceedingJoinPoint, methodName, circuitBreaker, returnType)).apply(); } 附录 参考 官方教程 How to configure to events in Resilience4j Spring starter ","date":"2024-02-02T11:18:46+08:00","image":"https://gloryjie.github.io/p/resilience4j-%E6%95%B4%E5%90%88springboot/cover_hu3163765b57fc9a9b6b4dbc88ef7da476_2717844_120x120_fill_q75_box_smart1.jpg","permalink":"https://gloryjie.github.io/p/resilience4j-%E6%95%B4%E5%90%88springboot/","title":"Resilience4j-整合Springboot"},{"content":" 交友：扩充圈子，多认识妹子，多花时间进行线上交流；舍得花钱打扮 阅读：非技术书籍20+本，技术书籍10+，网文1本 运动：践行干净增肌，8个月增肌、3个月减脂，目标65kg 游戏：打完5+游戏，死亡搁浅、只狼、艾尔登法环、ffe7等 技术提升：基础增强（网络、操作系统）、算法LC刷题100道、接触AIGC 技术课程：至少一门国外课程（看完并做完实验），例如MIT6.824、MIT6.S081 项目实践：设计一个个人项目并上线运行 投资理财：继续学习相关知识，在尽可能不增加资金的情况下，回本！ 生活体验：出行游玩，如武功山、武汉、九寨沟 新技能：手机摄影\u0026amp;剪辑 习惯养成目标\n12点前入睡，7点起 行路中，不玩手机 每周进行总结 每月1~2本书 降低拖延症 ","date":"2024-01-04T17:47:55+08:00","image":"https://gloryjie.github.io/p/2024%E5%B9%B4%E5%BA%A6%E8%AE%A1%E5%88%92/cover_hu6b62954a64c9532f0495ca1fd21ae92d_130115_120x120_fill_box_smart1_3.png","permalink":"https://gloryjie.github.io/p/2024%E5%B9%B4%E5%BA%A6%E8%AE%A1%E5%88%92/","title":"2024年度计划"}]