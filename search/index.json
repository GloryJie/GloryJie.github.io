[{"content":" 1 封面是《死亡搁浅》游戏中的 玛玛 官方有教程：https://resilience4j.readme.io/v1.7.0/docs/getting-started-3\n这里做个简单使用记录。 版本要求 Resilience4j版本 JDK版本 1.7 8 2.0 17 这里用的jdk8，使用Resilience4j的1.7版本。mvn依赖如下\n1 2 3 4 5 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;io.github.resilience4j\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;resilience4j-spring-boot2\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.7.1\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 这个包把Resilience4j的基本组件都引入进来了。\nyml配置 配置可以有三个层级的配置，分别可以继承。\n修改默认配置 自定义可共享的配置 实例自定义配置 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 resilience4j.circuitbreaker: # 指定对应的组件 configs: default: # 修改默认配置 slidingWindowSize: 100 permittedNumberOfCallsInHalfOpenState: 10 waitDurationInOpenState: 10000 failureRateThreshold: 60 eventConsumerBufferSize: 10 registerHealthIndicator: true someShared: # 可共享的配置 slidingWindowSize: 50 permittedNumberOfCallsInHalfOpenState: 10 instances: # 下面是实例自定义配置 backendA: # 实例名称 baseConfig: default # 指定继承的配置 waitDurationInOpenState: 5000 backendB: baseConfig: someShared 事件监听器 Resilience4j提供了两种细粒度的时间监听\nRegistry组件的增、删、替换事件 组件实例的状态变化事件 Resilience4j原生使用时在对应组件实例的基础上去进行设置监听，但是结合SpringBoot之后是没有办法直接拿到对应的组件实例。可以通过监听实例的增、删、替换的动作，进而拿到对应的实例，之后再进行监听实例状态的变更。\n自己创建的RegistryEventConsumer的Bean，会自动添加到SpringBoot自身管理的CircuitBreakerRegistry中。\n以监听CircuitBreaker组件为例，参考代码如下（IMessageService为自己的bean）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 @Bean public RegistryEventConsumer\u0026lt;CircuitBreaker\u0026gt; circuitBreakerEventConsumer(IMessageService messageService){ return new RegistryEventConsumer\u0026lt;CircuitBreaker\u0026gt;() { @Override public void onEntryAddedEvent(EntryAddedEvent\u0026lt;CircuitBreaker\u0026gt; entryAddedEvent) { entryAddedEvent.getAddedEntry().getEventPublisher().onStateTransition(event -\u0026gt; { String circuitBreakerName = event.getCircuitBreakerName(); CircuitBreaker.State fromState = event.getStateTransition().getFromState(); CircuitBreaker.State toState = event.getStateTransition().getToState(); log.info(\u0026#34;CircuitBreaker \u0026#39;{}\u0026#39; changed state from {} to {}\u0026#34;, circuitBreakerName, fromState, toState); StringBuilder builder = new StringBuilder(); builder.append(\u0026#34;\u0026lt;font color=\\\u0026#34;warning\\\u0026#34;\u0026gt;断路器状态发生变化 \u0026#34;).append(DateUtil.now()).append(\u0026#34; \u0026lt;/font\u0026gt;\\n\u0026#34;); builder.append(\u0026#34;\u0026gt; 断路器名称：\u0026#34;).append(circuitBreakerName).append(\u0026#34;\\n\u0026#34;); builder.append(\u0026#34;\u0026gt; 变化前状态：\u0026#34;).append(fromState).append(\u0026#34;\\n\u0026#34;); builder.append(\u0026#34;\u0026gt; 变化后状态：\u0026#34;).append(toState).append(\u0026#34;\\n\u0026#34;); builder.append(\u0026#34;请尽快处理！！！\u0026#34;); messageService.reportDefaultMsg(builder.toString()); }); } @Override public void onEntryRemovedEvent(EntryRemovedEvent\u0026lt;CircuitBreaker\u0026gt; entryRemoveEvent) { } @Override public void onEntryReplacedEvent(EntryReplacedEvent\u0026lt;CircuitBreaker\u0026gt; entryReplacedEvent) { } }; } 使用形式 注解使用 只需要在对应的方法加上对应组件的直接即可。还可以在添加降级处理的方，会自动根据异常类型进行批量。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 @CircuitBreaker(name = BACKEND, fallbackMethod = \u0026#34;fallback\u0026#34;) @RateLimiter(name = BACKEND) @Bulkhead(name = BACKEND, fallbackMethod = \u0026#34;fallback\u0026#34;) @Retry(name = BACKEND) @TimeLimiter(name = BACKEND) public Mono\u0026lt;String\u0026gt; method(String param1) { return Mono.error(new NumberFormatException()); } private Mono\u0026lt;String\u0026gt; fallback(String param1, CallNotPermittedException e) { return Mono.just(\u0026#34;Handled the exception when the CircuitBreaker is open\u0026#34;); } private Mono\u0026lt;String\u0026gt; fallback(String param1, BulkheadFullException e) { return Mono.just(\u0026#34;Handled the exception when the Bulkhead is full\u0026#34;); } private Mono\u0026lt;String\u0026gt; fallback(String param1, NumberFormatException e) { return Mono.just(\u0026#34;Handled the NumberFormatException\u0026#34;); } // 其实也可以写一个通用的，内部if else好了，减少方法的数量 private Mono\u0026lt;String\u0026gt; fallback(String param1, Exception e) { return Mono.just(\u0026#34;Handled any other exception\u0026#34;); } 代码使用 注解都是基于AOP去处理的，通病就是调用内部方法的时候是不会生效的。可以手动获取到对应的实力。\n1 2 3 4 5 @Resource private CircuitBreakerRegistry circuitBreakerRegistry; // 从registry获取实例，和注解使用的是同一个实例 circuitBreakerRegistry.circuitBreaker(\u0026#34;tencentAddressService\u0026#34;); starter的配置过程 结合SpringBoot的starter，流程基本就是读取配置，创建各种Bean组件。提供了各种注解，则过程就是基于Aop去实现的。这里简单看下CircuitBreaker的实现过程。\n基本涉及两个类\nCircuitBreakerConfiguration配置类，负责启动时创建断路器相关的Bean CircuitBreakerAspect切面处理，CircuitBreaker注解的处理 Bean的生成 两个关键的Bean\nCircuitBreakerRegistry CircuitBreakerAspect 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 @Bean @Primary public RegistryEventConsumer\u0026lt;CircuitBreaker\u0026gt; circuitBreakerRegistryEventConsumer( Optional\u0026lt;List\u0026lt;RegistryEventConsumer\u0026lt;CircuitBreaker\u0026gt;\u0026gt;\u0026gt; optionalRegistryEventConsumers) { // 自定义的RegistryEventConsumer会注入进来 return new CompositeRegistryEventConsumer\u0026lt;\u0026gt;( optionalRegistryEventConsumers.orElseGet(ArrayList::new)); } @Bean public CircuitBreakerRegistry circuitBreakerRegistry( EventConsumerRegistry\u0026lt;CircuitBreakerEvent\u0026gt; eventConsumerRegistry, RegistryEventConsumer\u0026lt;CircuitBreaker\u0026gt; circuitBreakerRegistryEventConsumer, @Qualifier(\u0026#34;compositeCircuitBreakerCustomizer\u0026#34;) CompositeCustomizer\u0026lt;CircuitBreakerConfigCustomizer\u0026gt; compositeCircuitBreakerCustomizer) { CircuitBreakerRegistry circuitBreakerRegistry = createCircuitBreakerRegistry( circuitBreakerProperties, circuitBreakerRegistryEventConsumer, compositeCircuitBreakerCustomizer); registerEventConsumer(circuitBreakerRegistry, eventConsumerRegistry); // then pass the map here initCircuitBreakerRegistry(circuitBreakerRegistry, compositeCircuitBreakerCustomizer); return circuitBreakerRegistry; } @Bean @Conditional(value = {AspectJOnClasspathCondition.class}) public CircuitBreakerAspect circuitBreakerAspect( CircuitBreakerRegistry circuitBreakerRegistry, @Autowired(required = false) List\u0026lt;CircuitBreakerAspectExt\u0026gt; circuitBreakerAspectExtList, FallbackDecorators fallbackDecorators, SpelResolver spelResolver ) { return new CircuitBreakerAspect(circuitBreakerProperties, circuitBreakerRegistry, circuitBreakerAspectExtList, fallbackDecorators, spelResolver); } 切面处理逻辑 切面的逻辑比较简单\n看看有没有注解 circuitBreakerRegistry中获取CircuitBreaker实例 是否使用fallback，不同的处理 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 @Pointcut(value = \u0026#34;@within(circuitBreaker) || @annotation(circuitBreaker)\u0026#34;, argNames = \u0026#34;circuitBreaker\u0026#34;) public void matchAnnotatedClassOrMethod(CircuitBreaker circuitBreaker) { } @Around(value = \u0026#34;matchAnnotatedClassOrMethod(circuitBreakerAnnotation)\u0026#34;, argNames = \u0026#34;proceedingJoinPoint, circuitBreakerAnnotation\u0026#34;) public Object circuitBreakerAroundAdvice(ProceedingJoinPoint proceedingJoinPoint, @Nullable CircuitBreaker circuitBreakerAnnotation) throws Throwable { // 方法上有没有注解 Method method = ((MethodSignature) proceedingJoinPoint.getSignature()).getMethod(); String methodName = method.getDeclaringClass().getName() + \u0026#34;#\u0026#34; + method.getName(); if (circuitBreakerAnnotation == null) { circuitBreakerAnnotation = getCircuitBreakerAnnotation(proceedingJoinPoint); } if (circuitBreakerAnnotation == null) { //because annotations wasn\u0026#39;t found return proceedingJoinPoint.proceed(); } // spel相关的 String backend = spelResolver.resolve(method, proceedingJoinPoint.getArgs(), circuitBreakerAnnotation.name()); io.github.resilience4j.circuitbreaker.CircuitBreaker circuitBreaker = getOrCreateCircuitBreaker( methodName, backend); Class\u0026lt;?\u0026gt; returnType = method.getReturnType(); String fallbackMethodValue = spelResolver.resolve(method, proceedingJoinPoint.getArgs(), circuitBreakerAnnotation.fallbackMethod()); // 没有fallback if (StringUtils.isEmpty(fallbackMethodValue)) { return proceed(proceedingJoinPoint, methodName, circuitBreaker, returnType); } // 有fallback FallbackMethod fallbackMethod = FallbackMethod .create(fallbackMethodValue, method, proceedingJoinPoint.getArgs(), proceedingJoinPoint.getTarget()); return fallbackDecorators.decorate(fallbackMethod, () -\u0026gt; proceed(proceedingJoinPoint, methodName, circuitBreaker, returnType)).apply(); } 附录 参考 官方教程 How to configure to events in Resilience4j Spring starter ","date":"2024-02-02T11:18:46+08:00","image":"https://gloryjie.github.io/p/resilience4j-%E6%95%B4%E5%90%88springboot/cover_hu3163765b57fc9a9b6b4dbc88ef7da476_2717844_120x120_fill_q75_box_smart1.jpg","permalink":"https://gloryjie.github.io/p/resilience4j-%E6%95%B4%E5%90%88springboot/","title":"Resilience4j-整合Springboot"},{"content":" 交友：扩充圈子，多认识妹子，多花时间进行线上交流；舍得花钱打扮 阅读：非技术书籍20+本，技术书籍10+，网文1本 运动：践行干净增肌，8个月增肌、3个月减脂，目标65kg 游戏：打完5+游戏，死亡搁浅、只狼、艾尔登法环、ffe7等 技术提升：基础增强（网络、操作系统）、算法LC刷题100道、接触AIGC 技术课程：至少一门国外课程（看完并做完实验），例如MIT6.824、MIT6.S081 项目实践：设计一个个人项目并上线运行 投资理财：继续学习相关知识，在尽可能不增加资金的情况下，回本！ 生活体验：出行游玩，如武功山、武汉、九寨沟 新技能：手机摄影\u0026amp;剪辑 习惯养成目标\n12点前入睡，7点起 行路中，不玩手机 每周进行总结 每月1~2本书 降低拖延症 ","date":"2024-01-04T17:47:55+08:00","image":"https://gloryjie.github.io/p/2024%E5%B9%B4%E5%BA%A6%E8%AE%A1%E5%88%92/cover_hu6b62954a64c9532f0495ca1fd21ae92d_130115_120x120_fill_box_smart1_3.png","permalink":"https://gloryjie.github.io/p/2024%E5%B9%B4%E5%BA%A6%E8%AE%A1%E5%88%92/","title":"2024年度计划"}]